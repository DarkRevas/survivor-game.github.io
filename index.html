<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Survivor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #gameCanvas {
            display: block;
            background: #1a1a2e;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        
        .top-bar {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 20px;
            margin-bottom: 8px;
        }

        .level-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .timer {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            border: 2px solid #444;
        }

        .health-container {
            width: 250px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 5px;
            border: 2px solid #333;
            margin-top: 10px;
        }

        .xp-container {
            width: 250px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 5px;
            border: 2px solid #333;
            margin-top: 8px;
        }

        .xp-bar {
            height: 20px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            border-radius: 6px;
            transition: width 0.3s ease;
            position: relative;
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        .health-bar {
            height: 20px;
            background: linear-gradient(90deg, #eb3349 0%, #f45c43 100%);
            border-radius: 6px;
            transition: width 0.2s ease;
            position: relative;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        .weapon-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }
        
        .weapon-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            overflow: hidden;
        }
        
        .weapon-slot.has-weapon {
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        .weapon-level {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            background: #667eea;
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
        }
        
        .bottom-stats {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 20px;
        }
        
        .bottom-stats.left {
            left: 20px;
        }
        
        .bottom-stats.right {
            right: 20px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            border: 2px solid #444;
            font-size: 14px;
        }
        
        .stat-label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 18px;
        }
        
        /* Level Up Screen */
        #levelUpScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            pointer-events: auto;
            z-index: 100;
        }
        
        .level-up-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .level-up-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 40px;
            text-shadow: 0 0 30px rgba(240, 147, 251, 0.5);
        }
        
        .upgrade-cards {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        .upgrade-card {
            width: 220px;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 3px solid #4a5568;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .upgrade-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .upgrade-card.common { border-color: #a0aec0; }
        .upgrade-card.rare { border-color: #4299e1; box-shadow: 0 0 20px rgba(66, 153, 225, 0.4); }
        .upgrade-card.epic { border-color: #9f7aea; box-shadow: 0 0 20px rgba(159, 122, 234, 0.4); }
        .upgrade-card.legendary { border-color: #ecc94b; box-shadow: 0 0 30px rgba(236, 201, 75, 0.5); }
        
        .upgrade-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
        }
        
        .upgrade-description {
            font-size: 13px;
            color: #a0aec0;
            margin-bottom: 15px;
        }
        
        .upgrade-rarity {
            font-size: 11px;
            text-transform: uppercase;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .upgrade-card.common .upgrade-rarity { background: #4a5568; color: #fff; }
        .upgrade-card.rare .upgrade-rarity { background: #2b6cb0; color: #fff; }
        .upgrade-card.epic .upgrade-rarity { background: #6b46c1; color: #fff; }
        .upgrade-card.legendary .upgrade-rarity { background: #975a16; color: #fff; }
        
        /* Game Over Screen */
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            pointer-events: auto;
            z-index: 100;
        }
        
        .game-over-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .game-over-title {
            font-size: 64px;
            font-weight: bold;
            color: #eb3349;
            margin-bottom: 30px;
        }
        
        .victory-title {
            font-size: 64px;
            font-weight: bold;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 10px;
        }
        
        .stat-item-label {
            color: #888;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .stat-item-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
        }
        
        /* Start Screen */
        #startScreen {
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            pointer-events: auto;
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .game-title {
            font-size: 72px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }
        
        .game-subtitle {
            font-size: 20px;
            color: #888;
            margin-bottom: 40px;
        }
        
        .controls-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: left;
        }
        
        .controls-info h3 {
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .controls-info p {
            margin: 5px 0;
            color: #aaa;
        }
        
        .start-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 20px 80px;
            font-size: 24px;
            color: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }
        
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }
        
        /* Pause Screen */
        #pauseScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            pointer-events: auto;
            z-index: 90;
            align-items: center;
            justify-content: center;
        }
        
        .pause-title {
            font-size: 48px;
            font-weight: bold;
            color: white;
        }
        
        /* Damage numbers */
        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 1px 1px 2px black;
        }
        
        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(1.2);
            }
        }

        /* Pickup Effects */
        @keyframes healthPickupPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes xpPickupPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes healFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        .pickup-effect {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
        }

        .pickup-effect.health {
            color: #4ade80;
            animation: healFloat 0.8s ease-out forwards;
        }

        .pickup-effect.xp {
            color: #667eea;
            animation: healFloat 0.6s ease-out forwards;
        }

        /* Weapon Selection Screen */
        #weaponSelectScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            pointer-events: auto;
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .weapon-select-title {
            font-size: 42px;
            font-weight: bold;
            color: white;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }

        .weapon-select-cards {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
        }

        .weapon-select-card {
            width: 180px;
            height: 220px;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 3px solid #4a5568;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .weapon-select-card:hover {
            transform: translateY(-10px);
            border-color: #667eea;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .weapon-select-icon {
            font-size: 56px;
            margin-bottom: 10px;
        }

        .weapon-select-name {
            font-size: 18px;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
        }

        .weapon-select-description {
            font-size: 13px;
            color: #a0aec0;
            line-height: 1.4;
        }

        /* Mobile adjustments for weapon selection */
        @media (max-width: 768px) {
            .weapon-select-title {
                font-size: 32px;
                margin-bottom: 30px;
            }

            .weapon-select-card {
                width: 160px;
                height: 200px;
                padding: 15px;
            }

            .weapon-select-icon {
                font-size: 48px;
            }

            .weapon-select-name {
                font-size: 16px;
            }

            .weapon-select-description {
                font-size: 12px;
            }
        }

        /* ==================== MOBILE TOUCH CONTROLS ==================== */
        
        /* Prevent default touch behaviors on canvas */
        #gameCanvas {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Virtual Joystick */
        #virtualJoystick {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 120px;
            height: 120px;
            pointer-events: none; /* Allow touch events to pass through when not active */
            z-index: 50;
            display: none;
        }

        #virtualJoystick.active {
            display: block;
        }

        .joystick-base {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(102, 126, 234, 0.8);
            border: 3px solid rgba(102, 126, 234, 1);
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            transition: transform 0.05s ease-out;
        }

        .joystick-stick.active {
            background: rgba(102, 126, 234, 1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.7);
        }

        /* Pause Button */
        #pauseButton {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 95;
            pointer-events: auto;
            transition: all 0.2s ease;
        }

        #pauseButton:active {
            transform: scale(0.9);
            background: rgba(102, 126, 234, 0.8);
        }

        #pauseButton svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        /* Mobile UI visibility */
        .mobile-ui #virtualJoystick {
            display: block;
        }

        .mobile-ui #pauseButton {
            display: flex;
        }

        /* Touch-friendly button sizes */
        @media (max-width: 768px) {
            .start-btn {
                padding: 20px 60px !important;
                font-size: 22px !important;
                min-height: 56px;
            }

            .restart-btn {
                padding: 18px 45px !important;
                font-size: 20px !important;
                min-height: 56px;
            }

            .upgrade-cards {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            .upgrade-card {
                width: 280px;
                min-height: 180px;
                padding: 15px;
            }

            .upgrade-icon {
                font-size: 40px;
            }

            .upgrade-name {
                font-size: 15px;
            }

            .upgrade-description {
                font-size: 12px;
            }

            .level-up-title {
                font-size: 36px;
            }

            .game-over-title,
            .victory-title {
                font-size: 42px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .stat-item {
                padding: 12px 20px;
            }

            .stat-item-value {
                font-size: 20px;
            }

            /* Larger HUD elements on mobile */
            .level-display {
                font-size: 16px;
                padding: 6px 12px;
            }

            .timer {
                font-size: 18px;
                padding: 6px 12px;
            }

            .health-container,
            .xp-container {
                width: 200px;
            }

            .health-bar,
            .xp-bar {
                height: 24px;
            }

            /* Adjust joystick position for smaller screens */
            #virtualJoystick {
                bottom: 60px;
                left: 60px;
            }

            .joystick-base,
            .joystick-stick {
                width: 100px;
                height: 100px;
            }

            .joystick-stick {
                width: 45px;
                height: 45px;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .upgrade-card {
                width: 260px;
                min-height: 160px;
            }

            #virtualJoystick {
                bottom: 40px;
                left: 40px;
            }

            .joystick-base {
                width: 100px;
                height: 100px;
            }

            .joystick-stick {
                width: 40px;
                height: 40px;
            }

            .game-title {
                font-size: 42px;
            }

            .game-subtitle {
                font-size: 16px;
            }

            .controls-info {
                padding: 15px 25px;
                font-size: 14px;
            }
        }

        /* Landscape orientation adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #virtualJoystick {
                bottom: 20px;
                left: 40px;
            }

            .joystick-base {
                width: 90px;
                height: 90px;
            }

            .joystick-stick {
                width: 40px;
                height: 40px;
            }

            .upgrade-cards {
                flex-wrap: wrap;
                max-width: 90vw;
            }

            .upgrade-card {
                width: 200px;
                min-height: 140px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <div class="top-bar">
                <div class="level-display">LVL: <span id="levelValue">1</span></div>
                <div class="timer" id="timer">00:00</div>
            </div>
            <div class="health-container">
                <div class="health-bar" id="healthBar" style="width: 100%">
                    <span class="health-text" id="healthText">100 / 100</span>
                </div>
            </div>
            <div class="xp-container">
                <div class="xp-bar" id="xpBar" style="width: 0%">
                </div>
            </div>
            <div class="weapon-bar" id="weaponBar"></div>
            <div class="bottom-stats right">
                <div class="stat-box">
                    <div class="stat-label">Wave</div>
                    <div class="stat-value" id="waveValue">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Kills</div>
                    <div class="stat-value" id="killsValue">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="levelUpScreen">
        <div class="level-up-content">
            <div class="level-up-title">‚òÖ LEVEL UP! ‚òÖ</div>
            <div class="upgrade-cards" id="upgradeCards"></div>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <div class="game-over-content">
            <div class="game-over-title" id="gameOverTitle">GAME OVER</div>
            <div class="stats-grid" id="endStats"></div>
            <button class="restart-btn" onclick="game.restart()">Play Again</button>
        </div>
    </div>
    
    <div id="startScreen">
        <div class="game-title">SHADOW SURVIVOR</div>
        <div class="game-subtitle">A Vampire Survivors-like Roguelike</div>
        <div class="controls-info">
            <h3>Controls</h3>
            <p><strong>WASD</strong> or <strong>Arrow Keys</strong> - Move</p>
            <p><strong>Touch & Drag</strong> (bottom-left) - Move (Mobile)</p>
            <p><strong>ESC</strong> or <strong>Pause Button</strong> - Pause</p>
            <p>Weapons auto-attack - Just survive!</p>
        </div>
        <button class="start-btn" onclick="game.start()">START GAME</button>
    </div>

    <div id="weaponSelectScreen">
        <div class="weapon-select-title">Choose Your Starting Weapon</div>
        <div class="weapon-select-cards" id="weaponSelectCards"></div>
    </div>

    <div id="pauseScreen">
        <div class="pause-title">PAUSED</div>
    </div>

    <!-- Mobile Touch Controls -->
    <div id="virtualJoystick">
        <div class="joystick-base"></div>
        <div class="joystick-stick" id="joystickStick"></div>
    </div>

    <button id="pauseButton" aria-label="Pause Game">
        <svg viewBox="0 0 24 24" id="pauseIcon">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
        <svg viewBox="0 0 24 24" id="playIcon" style="display: none;">
            <path d="M8 5v14l11-7z"/>
        </svg>
    </button>

    <script>
// ==================== GAME CONFIGURATION ====================
// OPTIMIZATION: Reduced entity limits for better performance
const CONFIG = {
    CANVAS_WIDTH: 1920,
    CANVAS_HEIGHT: 1080,
    FPS: 60,
    PLAYER_BASE_SPEED: 180,
    PLAYER_BASE_HP: 100,
    PLAYER_RADIUS: 16,
    MAP_BOUNDS: { width: 4000, height: 4000 },
    CAMERA_SMOOTHING: 0.1,
    XP_BASELINE: 10,
    MAX_LEVEL: 50,
    GAME_DURATION: 1800, // 30 minutes in seconds
    SPAWN_BASE_INTERVAL: 1.0,
    SPAWN_MIN_INTERVAL: 0.15,
    WAVE_DURATION: 20, // 20 seconds per wave (reduced from 30)

    // OPTIMIZATION: Reduced entity limits
    MAX_ENEMIES: 50,         // Reduced from 80
    MAX_PROJECTILES: 100,    // Reduced from 150
    MAX_PARTICLES: 50,       // Reduced from 100

    // Special Event Configuration
    BLOOD_MOON_CHANCE: 0.20,           // 20% chance every 5 waves
    BLOOD_MOON_INTERVAL: 5,            // Every 5 waves
    BLOOD_MOON_DURATION: 30,           // 30 seconds
    BLOOD_MOON_SPEED_MULTIPLIER: 1.5,  // +50% speed
    BLOOD_MOON_DAMAGE_MULTIPLIER: 1.25,// +25% damage
    BLOOD_MOON_SPAWN_MULTIPLIER: 0.5,  // Spawn rate doubles (interval halved)

    ENEMY_SIEGE_CHANCE: 0.30,          // 30% chance every 3 waves
    ENEMY_SIEGE_INTERVAL: 3,           // Every 3 waves
    ENEMY_SIEGE_COUNT: 10,             // 8-12 enemies spawn at once

    TREASURE_WAVE_CHANCE: 0.25,        // 25% chance every 4 waves
    TREASURE_WAVE_INTERVAL: 4,         // Every 4 waves
    TREASURE_WAVE_XP_BONUS: 0.50,      // +50% XP from gems
    // Health packs removed due to performance issues
};

// ==================== DECORATION COLOR PALETTES (cached for performance) ====================
const TREE_COLORS = [
    { foliage: '#0d0d1a', trunk: '#1a1a1a', shadow: '#06060a' },
    { foliage: '#1a2a2a', trunk: '#1a2020', shadow: '#0a1a1a' },
    { foliage: '#0f1f1f', trunk: '#151515', shadow: '#050f0f' },
    { foliage: '#1a3a3a', trunk: '#1a2525', shadow: '#0a1f1f' }
];

const ROCK_COLORS = [
    { base: '#2a2a3a', highlight: '#3a3a4a', crack: '#1a1a2a' },
    { base: '#3a3a4a', highlight: '#4a4a5a', crack: '#2a2a3a' },
    { base: '#2a3a3a', highlight: '#3a4a4a', crack: '#1a2a2a' },
    { base: '#3a2a4a', highlight: '#4a3a5a', crack: '#2a1a3a' }
];

const GRASS_COLORS = [
    { blade: '#1a3a1a', center: '#0f2a0f' },
    { blade: '#1a4a2a', center: '#0f3a1f' },
    { blade: '#2a5a3a', center: '#1a4a2a' },
    { blade: '#0f2a0f', center: '#0a1a0a' }
];

const RUINS_COLORS = [
    { base: '#3a3a4a', stroke: '#2a2a3a', missing: '#1a1a2e' },
    { base: '#4a4a5a', stroke: '#3a3a4a', missing: '#2a2a3e' },
    { base: '#3a4a5a', stroke: '#2a3a4a', missing: '#1a2a3e' },
    { base: '#4a3a5a', stroke: '#3a2a4a', missing: '#2a1a3e' }
];

const TOMBSTONE_COLORS = [
    { base: '#3a3a4a', stroke: '#2a2a3a', engraving: '#2a2a3a' },
    { base: '#4a4a5a', stroke: '#3a3a4a', engraving: '#3a3a4a' },
    { base: '#3a4a4a', stroke: '#2a3a3a', engraving: '#2a3a3a' }
];

// ==================== WEAPON DEFINITIONS ====================
const WEAPONS = {
    magicAura: {
        id: 'magicAura',
        name: 'Magic Aura',
        icon: 'üîÆ',
        description: 'Damages all enemies around you',
        baseDamage: 8,
        baseCooldown: 0.5,
        baseRange: 80,
        tickRate: 0.5,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 3 },
            { level: 3, range: 20 },
            { level: 4, damage: 3 },
            { level: 5, tickRate: -0.1 },
            { level: 6, range: 20 },
            { level: 7, damage: 4 },
            { level: 8, tickRate: -0.1 },
        ]
    },
    fireballArc: {
        id: 'fireballArc',
        name: 'Fireball Arc',
        icon: 'üî•',
        description: 'Explosive projectiles rain from above',
        baseDamage: 25,
        baseCooldown: 1.2,
        baseRange: 400,
        projectileSpeed: 300,
        explosionRadius: 60,
        projectileCount: 1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, projectileCount: 1 },
            { level: 4, range: 50 },
            { level: 5, damage: 10 },
            { level: 6, explosionRadius: 30 },
            { level: 7, projectileCount: 1 },
            { level: 8, range: 50 },
        ]
    },
    magicWand: {
        id: 'magicWand',
        name: 'Magic Wand',
        icon: 'ü™Ñ',
        description: 'Homing projectile seeks enemies',
        baseDamage: 15,
        baseCooldown: 0.8,
        baseRange: 500,
        projectileSpeed: 400,
        projectileCount: 1,
        pierce: 1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 8 },
            { level: 3, projectileCount: 1 },
            { level: 4, pierce: 1 },
            { level: 5, damage: 8 },
            { level: 6, projectileCount: 1 },
            { level: 7, pierce: 1 },
            { level: 8, damage: 8 },
        ]
    },
    throwingKnife: {
        id: 'throwingKnife',
        name: 'Throwing Knife',
        icon: 'üó°Ô∏è',
        description: 'Fast projectiles in facing direction',
        baseDamage: 12,
        baseCooldown: 0.4,
        baseRange: 250,
        projectileSpeed: 600,
        projectileCount: 1,
        critChance: 0.1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 5 },
            { level: 3, projectileCount: 1 },
            { level: 4, critChance: 0.05 },
            { level: 5, damage: 5 },
            { level: 6, projectileCount: 1 },
            { level: 7, range: 50 },
            { level: 8, damage: 5 },
        ]
    },
    lightningBolt: {
        id: 'lightningBolt',
        name: 'Lightning Bolt',
        icon: '‚ö°',
        description: 'Chains electricity between enemies',
        baseDamage: 20,
        baseCooldown: 1.0,
        baseRange: 400,
        chainCount: 3,
        chainRange: 150,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, chainCount: 2 },
            { level: 4, damage: 10 },
            { level: 5, chainRange: 50 },
            { level: 6, damage: 10 },
            { level: 7, chainCount: 2 },
            { level: 8, damage: 10 },
        ]
    },
    holyWater: {
        id: 'holyWater',
        name: 'Holy Water',
        icon: 'üíß',
        description: 'Creates damaging pools on ground',
        baseDamage: 10,
        baseCooldown: 1.5,
        baseRange: 500,
        poolDuration: 3,
        poolRadius: 70,
        tickRate: 0.3,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 5 },
            { level: 3, poolDuration: 1 },
            { level: 4, poolRadius: 25 },
            { level: 5, damage: 5 },
            { level: 6, tickRate: -0.1 },
            { level: 7, poolDuration: 1 },
            { level: 8, damage: 5 },
        ]
    },
    iceShard: {
        id: 'iceShard',
        name: 'Ice Shard',
        icon: 'üßä',
        description: 'Piercing projectiles that slow enemies',
        baseDamage: 10,
        baseCooldown: 0.6,
        baseRange: 350,
        projectileSpeed: 500,
        projectileCount: 1,
        pierce: 2,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 4 },
            { level: 3, pierce: 1 },
            { level: 4, range: 50 },
            { level: 5, damage: 4 },
            { level: 6, projectileCount: 1 },
            { level: 7, pierce: 1 },
            { level: 8, damage: 4 },
        ]
    },
    sacredCross: {
        id: 'sacredCross',
        name: 'Sacred Cross',
        icon: '‚úùÔ∏è',
        description: 'Rotating cross orbits around you',
        baseDamage: 6,
        baseCooldown: 0.3,
        baseRange: 100,
        projectileCount: 1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 3 },
            { level: 3, range: 25 },
            { level: 4, projectileCount: 1 },
            { level: 5, damage: 3 },
            { level: 6, range: 25 },
            { level: 7, projectileCount: 1 },
            { level: 8, damage: 4 },
        ]
    },
    poisonDagger: {
        id: 'poisonDagger',
        name: 'Poison Dagger',
        icon: 'üèπ',
        description: 'Applies poison dealing % max HP damage',
        baseDamage: 8,
        baseCooldown: 0.5,
        baseRange: 280,
        projectileSpeed: 550,
        projectileCount: 1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 3 },
            { level: 3, projectileCount: 1 },
            { level: 4, range: 50 },
            { level: 5, damage: 3 },
            { level: 6, projectileCount: 1 },
            { level: 7, range: 50 },
            { level: 8, damage: 4 },
        ]
    },
    spinBlade: {
        id: 'spinBlade',
        name: 'Spin Blade',
        icon: 'üåÄ',
        description: 'Boomerang blade hits twice',
        baseDamage: 18,
        baseCooldown: 1.0,
        baseRange: 300,
        projectileSpeed: 400,
        projectileCount: 1,
        pierce: 0,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 6 },
            { level: 3, range: 50 },
            { level: 4, projectileCount: 1 },
            { level: 5, damage: 6 },
            { level: 6, range: 50 },
            { level: 7, projectileCount: 1 },
            { level: 8, damage: 8 },
        ]
    },
    soulOrb: {
        id: 'soulOrb',
        name: 'Soul Orb',
        icon: 'üîÆ',
        description: '3 orbs orbit you and explode on enemy contact',
        baseDamage: 25,
        baseCooldown: 4.0, // Spawn orbs every 4 seconds
        baseRange: 200,
        projectileSpeed: 250,
        projectileCount: 3, // Always 3 orbs per spawn
        orbLifetime: 4, // Orbs last 4 seconds then explode
        explosionDamage: 1.5, // 150% damage on explosion
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, explosionDamage: 0.5 },
            { level: 4, range: 30 },
            { level: 5, damage: 10 },
            { level: 6, orbLifetime: 1 },
            { level: 7, range: 30 },
            { level: 8, damage: 10 },
        ]
    },
    boneSpear: {
        id: 'boneSpear',
        name: 'Bone Spear',
        icon: 'ü¶¥',
        description: 'Piercing projectile that travels in a straight line',
        baseDamage: 25,
        baseCooldown: 1.2,
        baseRange: 500,
        projectileSpeed: 550,
        projectileCount: 1,
        pierce: 999,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, projectileCount: 1 },
            { level: 4, damage: 10 },
            { level: 5, range: 50 },
            { level: 6, projectileCount: 1 },
            { level: 7, damage: 10 },
            { level: 8, range: 50 },
        ]
    },
    bloodMoonChakram: {
        id: 'bloodMoonChakram',
        name: 'Blood Moon Chakram',
        icon: 'üåô',
        description: 'Crescent blade that flies out and returns',
        baseDamage: 30,
        baseCooldown: 1.0,
        baseRange: 350,
        projectileSpeed: 400,
        projectileCount: 1,
        pierce: 1,
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, projectileCount: 1 },
            { level: 4, range: 40 },
            { level: 5, damage: 10 },
            { level: 6, projectileCount: 1 },
            { level: 7, pierce: 1 },
            { level: 8, damage: 10 },
        ]
    },
    vampireDagger: {
        id: 'vampireDagger',
        name: 'Vampire Dagger',
        icon: 'üó°Ô∏è',
        description: 'Dagger that fires every 3s and heals +1 HP on hit',
        baseDamage: 25,
        baseCooldown: 3.0, // Fires once every 3 seconds
        baseRange: 200,
        projectileSpeed: 500,
        projectileCount: 1,
        lifestealHeal: 1, // Fixed +1 HP heal (doesn't scale)
        critChance: 0.1, // Base 10% crit chance
        maxLevel: 8,
        upgrades: [
            { level: 2, damage: 10 },
            { level: 3, critChance: 0.05 }, // +5% crit
            { level: 4, damage: 10 },
            { level: 5, damage: 10 },
            { level: 6, critChance: 0.05 }, // +5% crit
            { level: 7, damage: 10 },
            { level: 8, critChance: 0.05 }, // +5% crit (total +15%)
        ]
    }
};

// ==================== PASSIVE DEFINITIONS ====================
const PASSIVES = {
    swiftness: {
        id: 'swiftness',
        name: 'Swiftness Boots',
        icon: 'üë¢',
        description: 'Increases movement speed',
        maxLevel: 5,
        values: [0.1, 0.1, 0.1, 0.1, 0.1],
        stat: 'movementSpeed'
    },
    haste: {
        id: 'haste',
        name: 'Haste Glyph',
        icon: '‚è±Ô∏è',
        description: 'Increases attack speed',
        maxLevel: 5,
        values: [0.08, 0.08, 0.08, 0.08, 0.08],
        stat: 'attackSpeed'
    },
    power: {
        id: 'power',
        name: 'Power Crystal',
        icon: 'üíé',
        description: 'Increases all damage',
        maxLevel: 5,
        values: [0.1, 0.1, 0.1, 0.1, 0.1],
        stat: 'damage'
    },
    vitality: {
        id: 'vitality',
        name: 'Vitality Heart',
        icon: '‚ù§Ô∏è',
        description: 'Increases max health',
        maxLevel: 5,
        values: [20, 20, 30, 30, 50],
        stat: 'maxHealth'
    },
    amplification: {
        id: 'amplification',
        name: 'Amplification Orb',
        icon: 'üîä',
        description: 'Increases area of effect',
        maxLevel: 5,
        values: [0.1, 0.1, 0.15, 0.15, 0.2],
        stat: 'area'
    },
    cooldown: {
        id: 'cooldown',
        name: 'Cooldown Charm',
        icon: 'üìø',
        description: 'Reduces cooldowns',
        maxLevel: 5,
        values: [0.05, 0.05, 0.07, 0.08, 0.1],
        stat: 'cooldownReduction'
    },
    goldMagnet: {
        id: 'goldMagnet',
        name: 'Gold Magnet',
        icon: 'üß≤',
        description: 'Increases pickup range for XP gems and gold',
        maxLevel: 5,
        values: [0.1, 0.1, 0.15, 0.15, 0.2],
        stat: 'pickupRange'
    },
    volley: {
        id: 'volley',
        name: 'Volley Feather',
        icon: 'ü™∂',
        description: '+1 Projectile for all weapons',
        maxLevel: 3,
        values: [1, 1, 1],
        stat: 'projectileCount'
    },
    regeneration: {
        id: 'regeneration',
        name: 'Regeneration Candle',
        icon: 'üïØÔ∏è',
        description: 'Regenerates HP over time',
        maxLevel: 5,
        values: [1, 1, 1, 1, 1],
        stat: 'regeneration'
    },
    luck: {
        id: 'luck',
        name: 'Luck Clover',
        icon: 'üçÄ',
        description: 'Increases crit chance and XP gain',
        maxLevel: 5,
        values: [0.03, 0.03, 0.03, 0.03, 0.03],
        xpBonus: [0.05, 0.05, 0.05, 0.05, 0.05],
        stat: 'luck'
    },
    thorns: {
        id: 'thorns',
        name: 'Thorn Armor',
        icon: 'üõ°Ô∏è',
        description: 'Reflects damage when hit',
        maxLevel: 5,
        values: [5, 2, 2, 2, 2],
        stat: 'thornDamage'
    }
};

// ==================== ENEMY DEFINITIONS ====================
const ENEMIES = {
    zombie: {
        id: 'zombie',
        name: 'Zombie',
        color: '#4a7c4e',
        baseHp: 30, // +30% HP, +15% damage
        baseDamage: 6,
        baseSpeed: 60,
        radius: 14,
        xpValue: 5,
        attackSpeed: 1.0
    },
    ghoul: {
        id: 'ghoul',
        name: 'Ghoul',
        color: '#8b4513',
        baseHp: 20, // +30% HP, +15% damage
        baseDamage: 9,
        baseSpeed: 140,
        radius: 12,
        xpValue: 8,
        attackSpeed: 0.8
    },
    skeleton: {
        id: 'skeleton',
        name: 'Skeleton',
        color: '#d4c5a3',
        baseHp: 156, // +30% HP, +15% damage
        baseDamage: 17,
        baseSpeed: 40,
        radius: 18,
        xpValue: 25,
        attackSpeed: 1.5,
        knockbackResist: 0.5
    },
    witch: {
        id: 'witch',
        name: 'Witch',
        color: '#6b2c91',
        baseHp: 59, // +30% HP, +15% damage
        baseDamage: 14,
        baseSpeed: 80,
        radius: 14,
        xpValue: 20,
        attackSpeed: 2.0,
        attackRange: 300,
        isRanged: true
    },
    shadowStalker: {
        id: 'shadowStalker',
        name: 'Shadow Stalker',
        color: '#2d2d2d',
        baseHp: 49, // +30% HP, +15% damage
        baseDamage: 12,
        baseSpeed: 110,
        radius: 13,
        xpValue: 12,
        attackSpeed: 0.9,
        waveRequirement: 4
    },
    demonImp: {
        id: 'demonImp',
        name: 'Demon Imp',
        color: '#c44536',
        baseHp: 16, // +30% HP, +15% damage
        baseDamage: 7,
        baseSpeed: 160,
        radius: 10,
        xpValue: 10,
        attackSpeed: 0.7,
        waveRequirement: 3
    },
    cursedKnight: {
        id: 'cursedKnight',
        name: 'Cursed Knight',
        color: '#5a6b7c',
        baseHp: 234, // +30% HP, +15% damage
        baseDamage: 21,
        baseSpeed: 35,
        radius: 20,
        xpValue: 35,
        attackSpeed: 1.8,
        knockbackResist: 0.7,
        waveRequirement: 6
    },
    plagueBats: {
        id: 'plagueBats',
        name: 'Plague Bats',
        color: '#6b8c42',
        baseHp: 23, // +30% HP, +15% damage
        baseDamage: 5,
        baseSpeed: 130,
        radius: 8,
        xpValue: 8,
        attackSpeed: 0.6,
        waveRequirement: 5
    },
    necromancer: {
        id: 'necromancer',
        name: 'Necromancer',
        color: '#4a2d5c',
        baseHp: 88, // +30% HP, +15% damage
        baseDamage: 9,
        baseSpeed: 55,
        radius: 14,
        xpValue: 30,
        attackSpeed: 2.5,
        attackRange: 350,
        isRanged: true,
        waveRequirement: 7
    },
    voidReaper: {
        id: 'voidReaper',
        name: 'Void Reaper',
        color: '#3d1f4a',
        baseHp: 780, // +30% HP, +15% damage
        baseDamage: 29,
        baseSpeed: 70,
        radius: 24,
        xpValue: 150,
        attackSpeed: 1.2,
        knockbackResist: 0.8,
        waveRequirement: 10,
        isMiniBoss: true
    },
    cryptWraith: {
        id: 'cryptWraith',
        name: 'Crypt Wraith',
        color: '#7d6b8f',
        baseHp: 46, // +30% HP, +15% damage
        baseDamage: 14,
        baseSpeed: 75,
        radius: 15,
        xpValue: 22,
        attackSpeed: 1.0,
        waveRequirement: 5,
        knockbackResist: 1.0 // Can't be knocked back
    },
    berserkerMutant: {
        id: 'berserkerMutant',
        name: 'Berserker Mutant',
        color: '#8b3d3d',
        baseHp: 72, // +30% HP, +15% damage
        baseDamage: 23,
        baseSpeed: 95,
        radius: 18,
        xpValue: 30,
        attackSpeed: 1.5,
        waveRequirement: 6,
        enrageThreshold: 0.5 // Speed increases below 50% HP
    },
    darkPriest: {
        id: 'darkPriest',
        name: 'Dark Priest',
        color: '#2d1a4a',
        baseHp: 65, // +30% HP, +15% damage
        baseDamage: 17,
        baseSpeed: 45,
        radius: 16,
        xpValue: 35,
        attackSpeed: 2.0,
        attackRange: 350,
        isRanged: true,
        waveRequirement: 8
    },
    crystalGolem: {
        id: 'crystalGolem',
        name: 'Crystal Golem',
        color: '#4a9d8b',
        baseHp: 195, // +30% HP, +15% damage
        baseDamage: 21,
        baseSpeed: 25,
        radius: 22,
        xpValue: 50,
        attackSpeed: 1.2,
        knockbackResist: 0.9,
        waveRequirement: 9,
        thornReflect: 0.1 // Reflects 10% damage
    },
    // BOSSES
    lordOfBones: {
        id: 'lordOfBones',
        name: 'Lord of Bones',
        color: '#c4b494',
        baseHp: 1040, // +30% HP, +15% damage
        baseDamage: 35,
        baseSpeed: 40,
        radius: 35,
        xpValue: 500,
        attackSpeed: 1.5,
        knockbackResist: 1.0,
        waveRequirement: 5,
        isBoss: true,
        specialAbility: 'bone_spear' // Fires bone spears
    },
    bloodQueen: {
        id: 'bloodQueen',
        name: 'Blood Queen',
        color: '#8b0000',
        baseHp: 1560, // +30% HP, +15% damage
        baseDamage: 40,
        baseSpeed: 55,
        radius: 32,
        xpValue: 750,
        attackSpeed: 1.8,
        knockbackResist: 1.0,
        waveRequirement: 10,
        isBoss: true,
        specialAbility: 'blood_bolt' // Fires homing blood bolts
    },
    voidLord: {
        id: 'voidLord',
        name: 'Void Lord',
        color: '#2d1a4a',
        baseHp: 2600, // +30% HP, +15% damage
        baseDamage: 52,
        baseSpeed: 35,
        radius: 40,
        xpValue: 1500,
        attackSpeed: 1.2,
        knockbackResist: 1.0,
        waveRequirement: 15,
        isBoss: true,
        specialAbility: 'void_blast' // Creates void zones
    }
};

// ==================== OBJECT POOLING ====================
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 100) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = [];
        
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
        }
    }
    
    get() {
        let obj;
        if (this.pool.length > 0) {
            obj = this.pool.pop();
        } else {
            obj = this.createFn();
        }
        this.active.push(obj);
        return obj;
    }
    
    release(obj) {
        const index = this.active.indexOf(obj);
        if (index !== -1) {
            this.active.splice(index, 1);
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }
    
    releaseAll() {
        while (this.active.length > 0) {
            this.release(this.active[0]);
        }
    }
}

// ==================== SPATIAL HASH GRID ====================
// OPTIMIZATION: Only rebuild spatial hash when enemies have moved
class SpatialHash {
    constructor(cellSize = 100) {
        this.cellSize = cellSize;
        this.grid = new Map();
        this.dirty = true; // Track if rebuild is needed
        this.lastEnemyPositions = new Map(); // Track enemy positions for change detection
    }

    clear() {
        this.grid.clear();
        this.lastEnemyPositions.clear();
        this.dirty = true;
    }

    // OPTIMIZATION: Check if enemies have moved since last build
    checkDirty(enemies) {
        if (this.dirty) return true;
        if (enemies.length !== this.lastEnemyPositions.size) return true;
        
        const len = enemies.length;
        for (let i = 0; i < len; i++) {
            const enemy = enemies[i];
            const key = enemy.type + '_' + i; // Unique key per enemy
            const lastPos = this.lastEnemyPositions.get(key);
            if (!lastPos || Math.abs(lastPos.x - enemy.x) > 1 || Math.abs(lastPos.y - enemy.y) > 1) {
                return true;
            }
        }
        return false;
    }

    // OPTIMIZATION: Store positions after building
    storePositions(enemies) {
        this.lastEnemyPositions.clear();
        const len = enemies.length;
        for (let i = 0; i < len; i++) {
            const enemy = enemies[i];
            const key = enemy.type + '_' + i;
            this.lastEnemyPositions.set(key, { x: enemy.x, y: enemy.y });
        }
        this.dirty = false;
    }

    getKey(x, y) {
        const gx = Math.floor(x / this.cellSize);
        const gy = Math.floor(y / this.cellSize);
        return `${gx},${gy}`;
    }

    insert(entity) {
        const key = this.getKey(entity.x, entity.y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(entity);
    }

    query(x, y, radius) {
        const results = [];
        const minGx = Math.floor((x - radius) / this.cellSize);
        const maxGx = Math.floor((x + radius) / this.cellSize);
        const minGy = Math.floor((y - radius) / this.cellSize);
        const maxGy = Math.floor((y + radius) / this.cellSize);

        for (let gx = minGx; gx <= maxGx; gx++) {
            for (let gy = minGy; gy <= maxGy; gy++) {
                const key = `${gx},${gy}`;
                const cell = this.grid.get(key);
                if (cell) {
                    results.push(...cell);
                }
            }
        }
        return results;
    }
}

// ==================== INPUT HANDLER ====================
class InputHandler {
    constructor() {
        this.keys = {};
        this.joystickMovement = { dx: 0, dy: 0 };
        this.setupListeners();
    }

    setupListeners() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (e.code === 'Escape') {
                game.togglePause();
            }
        });
        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    }

    setJoystickMovement(dx, dy) {
        this.joystickMovement = { dx, dy };
    }

    getMovement() {
        let dx = 0, dy = 0;

        // Keyboard input
        if (this.keys['KeyW'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) dx += 1;

        // Normalize keyboard diagonal movement
        if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx * dx + dy * dy);
            dx /= length;
            dy /= length;
        }

        // Joystick input takes priority if active
        if (this.joystickMovement.dx !== 0 || this.joystickMovement.dy !== 0) {
            dx = this.joystickMovement.dx;
            dy = this.joystickMovement.dy;
        }

        return { dx, dy };
    }

    resetJoystick() {
        this.joystickMovement = { dx: 0, dy: 0 };
    }
}

// ==================== VIRTUAL JOYSTICK ====================
class VirtualJoystick {
    constructor(containerElement) {
        this.container = containerElement;
        this.stickElement = document.getElementById('joystickStick');
        this.baseElement = this.container.querySelector('.joystick-base');
        
        this.active = false;
        this.touchId = null;
        this.baseX = 0;
        this.baseY = 0;
        this.stickX = 0;
        this.stickY = 0;
        this.maxDistance = 35; // Maximum stick movement from center (pixels)
        
        this.movement = { dx: 0, dy: 0 };
        
        this.setupTouchListeners();
        this.setupResizeListener();
        this.updatePosition();
    }

    setupTouchListeners() {
        // Touch events on the container area
        this.container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.container.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
        this.container.addEventListener('touchcancel', (e) => this.handleTouchEnd(e), { passive: false });

        // Also listen on canvas for joystick activation anywhere on screen
        // This allows player to touch anywhere in bottom-left area to activate joystick
        document.addEventListener('touchstart', (e) => this.handleGlobalTouchStart(e), { passive: false });
        document.addEventListener('touchmove', (e) => this.handleGlobalTouchMove(e), { passive: false });
        document.addEventListener('touchend', (e) => this.handleGlobalTouchEnd(e), { passive: false });
    }

    setupResizeListener() {
        window.addEventListener('resize', () => this.updatePosition());
    }

    updatePosition() {
        // Update joystick position based on screen size
        const isMobile = this.isMobileDevice();
        if (isMobile) {
            if (window.innerWidth <= 480) {
                this.container.style.bottom = '40px';
                this.container.style.left = '40px';
            } else if (window.innerWidth <= 768) {
                this.container.style.bottom = '60px';
                this.container.style.left = '60px';
            } else {
                this.container.style.bottom = '80px';
                this.container.style.left = '80px';
            }
        }
    }

    isMobileDevice() {
        return 'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 ||
               window.innerWidth <= 768;
    }

    isInJoystickArea(x, y) {
        // Check if touch is in the bottom-left quadrant of the screen
        const thresholdX = window.innerWidth * 0.4;
        const thresholdY = window.innerHeight * 0.6;
        return x < thresholdX && y > thresholdY;
    }

    handleGlobalTouchStart(e) {
        if (this.active) return;

        const touch = e.changedTouches[0];
        if (this.isInJoystickArea(touch.clientX, touch.clientY)) {
            this.startTouch(touch.clientX, touch.clientY, touch.identifier);
            e.preventDefault();
        }
    }

    handleGlobalTouchMove(e) {
        if (!this.active) return;

        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                this.moveTouch(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                e.preventDefault();
                break;
            }
        }
    }

    handleGlobalTouchEnd(e) {
        if (!this.active) return;

        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                this.endTouch();
                e.preventDefault();
                break;
            }
        }
    }

    handleTouchStart(e) {
        if (this.active) return;

        const touch = e.changedTouches[0];
        this.startTouch(touch.clientX, touch.clientY, touch.identifier);
        e.preventDefault();
    }

    handleTouchMove(e) {
        if (!this.active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                this.moveTouch(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                e.preventDefault();
                break;
            }
        }
    }

    handleTouchEnd(e) {
        if (!this.active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === this.touchId) {
                this.endTouch();
                e.preventDefault();
                break;
            }
        }
    }

    startTouch(clientX, clientY, touchId) {
        this.active = true;
        this.touchId = touchId;

        // Get the base center position
        const rect = this.baseElement.getBoundingClientRect();
        this.baseX = rect.left + rect.width / 2;
        this.baseY = rect.top + rect.height / 2;

        // Initialize stick at touch position (clamped to max distance)
        this.moveStick(clientX, clientY);

        // Visual feedback
        this.container.classList.add('active');
        if (this.stickElement) {
            this.stickElement.classList.add('active');
        }
    }

    moveTouch(clientX, clientY) {
        if (!this.active) return;
        this.moveStick(clientX, clientY);
    }

    moveStick(clientX, clientY) {
        // Calculate displacement from base center
        let deltaX = clientX - this.baseX;
        let deltaY = clientY - this.baseY;
        
        // Calculate distance and clamp to max
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > this.maxDistance) {
            const scale = this.maxDistance / distance;
            deltaX *= scale;
            deltaY *= scale;
        }
        
        this.stickX = deltaX;
        this.stickY = deltaY;
        
        // Update stick visual position
        if (this.stickElement) {
            this.stickElement.style.transform = `translate(calc(-50% + ${this.stickX}px), calc(-50% + ${this.stickY}px))`;
        }
        
        // Calculate normalized movement values (-1 to 1)
        const normalizedDistance = distance / this.maxDistance;
        const angle = Math.atan2(deltaY, deltaX);
        
        this.movement.dx = Math.cos(angle) * normalizedDistance;
        this.movement.dy = Math.sin(angle) * normalizedDistance;
        
        // Update InputHandler
        if (game && game.input) {
            game.input.setJoystickMovement(this.movement.dx, this.movement.dy);
        }
    }

    endTouch() {
        this.active = false;
        this.touchId = null;
        this.stickX = 0;
        this.stickY = 0;
        this.movement = { dx: 0, dy: 0 };
        
        // Reset stick visual position
        if (this.stickElement) {
            this.stickElement.style.transform = 'translate(-50%, -50%)';
            this.stickElement.classList.remove('active');
        }
        this.container.classList.remove('active');
        
        // Reset InputHandler
        if (game && game.input) {
            game.input.resetJoystick();
        }
    }

    getMovement() {
        return { ...this.movement };
    }

    setActive(active) {
        if (!active) {
            this.endTouch();
        }
    }
}

// ==================== PARTICLE SYSTEM ====================
class ParticleSystem {
    constructor() {
        // OPTIMIZATION: Use CONFIG.MAX_PARTICLES for performance limit
        this.particles = [];
        this.MAX_PARTICLES = CONFIG.MAX_PARTICLES;
    }

    emit(x, y, config) {
        // Don't emit if at max capacity
        if (this.particles.length >= this.MAX_PARTICLES) return;

        const particle = {
            x, y,
            vx: config.vx || (Math.random() - 0.5) * 100,
            vy: config.vy || (Math.random() - 0.5) * 100,
            life: config.life || 1,
            maxLife: config.life || 1,
            size: config.size || 5,
            color: config.color || '#fff',
            gravity: config.gravity || 0,
            drag: config.drag || 1,
            type: config.type || 'circle'
        };
        this.particles.push(particle);
    }

    // OPTIMIZATION: Reduced particle count from 8 to 4
    emitBlood(x, y) {
        for (let i = 0; i < 4; i++) {
            this.emit(x, y, {
                vx: (Math.random() - 0.5) * 200,
                vy: (Math.random() - 0.5) * 200,
                life: 0.5 + Math.random() * 0.3,
                size: 3 + Math.random() * 4,
                color: `hsl(${0 + Math.random() * 20}, 80%, 50%)`,
                gravity: 50,
                drag: 0.95
            });
        }
    }

    // OPTIMIZATION: Reduced particle count from 5 to 2
    emitXP(x, y) {
        for (let i = 0; i < 2; i++) {
            this.emit(x, y, {
                vx: (Math.random() - 0.5) * 150,
                vy: (Math.random() - 0.5) * 150,
                life: 0.3 + Math.random() * 0.2,
                size: 2 + Math.random() * 3,
                color: `hsl(${180 + Math.random() * 60}, 80%, 60%)`,
                drag: 0.9
            });
        }
    }

    // OPTIMIZATION: Reduced particle count from 15 to 6
    emitExplosion(x, y, color) {
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i;
            const speed = 100 + Math.random() * 100;
            this.emit(x, y, {
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0.4 + Math.random() * 0.2,
                size: 4 + Math.random() * 4,
                color: color,
                drag: 0.92
            });
        }
    }

    // OPTIMIZATION: Cache array length and use indexed loop for better performance
    update(dt) {
        const len = this.particles.length;
        for (let i = len - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += p.gravity * dt;
            p.vx *= p.drag;
            p.vy *= p.drag;
            p.life -= dt;

            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }

    // OPTIMIZATION: Cache array length for iteration
    render(ctx) {
        const len = this.particles.length;
        for (let i = 0; i < len; i++) {
            const p = this.particles[i];
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;

            if (p.type === 'circle') {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 'square') {
                ctx.fillRect(p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
            }
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== DAMAGE NUMBER SYSTEM ====================
class DamageNumberSystem {
    constructor() {
        this.numbers = [];
    }
    
    add(x, y, damage, isCrit = false) {
        this.numbers.push({
            x, y,
            damage: Math.round(damage),
            life: 1,
            isCrit,
            vy: -50 - Math.random() * 30
        });
    }
    
    update(dt) {
        for (let i = this.numbers.length - 1; i >= 0; i--) {
            const n = this.numbers[i];
            n.y += n.vy * dt;
            n.life -= dt;
            
            if (n.life <= 0) {
                this.numbers.splice(i, 1);
            }
        }
    }
    
    // OPTIMIZATION: Cache array length for iteration
    render(ctx, cameraX, cameraY) {
        const len = this.numbers.length;
        for (let i = 0; i < len; i++) {
            const n = this.numbers[i];
            const screenX = n.x - cameraX;
            const screenY = n.y - cameraY;

            if (screenX < -50 || screenX > CONFIG.CANVAS_WIDTH + 50 ||
                screenY < -50 || screenY > CONFIG.CANVAS_HEIGHT + 50) continue;

            const alpha = n.life;
            const scale = n.isCrit ? 1.5 : 1;

            ctx.globalAlpha = alpha;
            ctx.font = `bold ${16 * scale}px Arial`;

            // Check if this is a heal effect (string with + prefix)
            const isHeal = typeof n.damage === 'string' && n.damage.startsWith('+');

            if (isHeal) {
                // Green heal text
                ctx.fillStyle = '#4ade80';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText(n.damage, screenX, screenY);
                ctx.fillText(n.damage, screenX, screenY);
            } else {
                // Regular damage numbers
                ctx.fillStyle = n.isCrit ? '#ffcc00' : '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText(n.damage, screenX, screenY);
                ctx.fillText(n.damage, screenX, screenY);
            }
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== ENTITY CLASSES ====================
class Player {
    constructor() {
        this.x = CONFIG.MAP_BOUNDS.width / 2;
        this.y = CONFIG.MAP_BOUNDS.height / 2;
        this.hp = CONFIG.PLAYER_BASE_HP;
        this.maxHp = CONFIG.PLAYER_BASE_HP;
        this.speed = CONFIG.PLAYER_BASE_SPEED;
        this.level = 1;
        this.xp = 0;
        this.xpToNext = this.getXpForLevel(1);
        this.weapons = [];
        this.passives = {};
        this.damageMultiplier = 1;
        this.attackSpeedMultiplier = 1;
        this.cooldownReduction = 0;
        this.areaMultiplier = 1;
        this.projectileBonus = 0;
        this.movementBonus = 0;
        this.facing = { x: 1, y: 0 }; // Default facing right
        this.invincible = false;
        this.invincibleTimer = 0;
        this.radius = CONFIG.PLAYER_RADIUS;
        this.regeneration = 0; // HP per second from regeneration
    }
    
    getXpForLevel(level) {
        if (level < 10) {
            return CONFIG.XP_BASELINE + (level - 1) * 5;
        }
        return 95 + (level - 10) * 25;
    }
    
    addXp(amount) {
        this.xp += amount;
        let leveledUp = false;

        while (this.xp >= this.xpToNext && this.level < CONFIG.MAX_LEVEL) {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = this.getXpForLevel(this.level);
            leveledUp = true;
        }

        return leveledUp;
    }
    
    takeDamage(amount) {
        if (this.invincible) return false;
        
        this.hp -= amount;
        this.invincible = true;
        this.invincibleTimer = 0.5;
        
        return this.hp <= 0;
    }
    
    heal(amount) {
        this.hp = Math.min(this.hp + amount, this.maxHp);
    }
    
    update(dt, input) {
        const movement = input.getMovement();
        
        if (movement.dx !== 0 || movement.dy !== 0) {
            this.facing = { x: movement.dx, y: movement.dy };
            // Normalize
            const len = Math.sqrt(this.facing.x ** 2 + this.facing.y ** 2);
            this.facing.x /= len;
            this.facing.y /= len;
        }
        
        const speed = this.speed * (1 + this.movementBonus);
        this.x += movement.dx * speed * dt;
        this.y += movement.dy * speed * dt;
        
        // Clamp to map bounds
        this.x = Math.max(this.speed, Math.min(CONFIG.MAP_BOUNDS.width - this.speed, this.x));
        this.y = Math.max(this.speed, Math.min(CONFIG.MAP_BOUNDS.height - this.speed, this.y));
        
        // Update invincibility
        if (this.invincible) {
            this.invincibleTimer -= dt;
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
            }
        }

        // Apply regeneration
        if (this.regeneration > 0 && this.hp < this.maxHp) {
            this.hp = Math.min(this.hp + this.regeneration * dt, this.maxHp);
        }

        // OPTIMIZATION: Cache array length for weapon cooldown update
        const len = this.weapons.length;
        for (let i = 0; i < len; i++) {
            const weapon = this.weapons[i];
            if (weapon.currentCooldown > 0) {
                weapon.currentCooldown -= dt;
            }
        }
    }
    
    getEffectiveStat(stat, baseValue) {
        let multiplier = 1;
        
        switch (stat) {
            case 'damage':
                multiplier = this.damageMultiplier;
                break;
            case 'cooldown':
                multiplier = 1 - Math.min(0.5, this.cooldownReduction);
                break;
            case 'area':
                multiplier = this.areaMultiplier;
                break;
            case 'attackSpeed':
                multiplier = this.attackSpeedMultiplier;
                break;
        }
        
        return baseValue * multiplier;
    }
}

class Enemy {
    constructor(type, x, y, waveMultiplier) {
        const data = ENEMIES[type];
        this.type = type;
        this.x = x;
        this.y = y;
        this.hp = data.baseHp * waveMultiplier;
        this.maxHp = this.hp;
        // REDUCED damage scaling: 0.08 ‚Üí 0.02 (4x slower damage growth)
        this.damage = data.baseDamage * (1 + 0.02 * waveMultiplier);
        this.baseSpeed = data.baseSpeed;
        this.speed = this.baseSpeed;
        this.radius = data.radius;
        this.xpValue = data.xpValue;
        this.attackSpeed = data.attackSpeed;
        this.attackCooldown = 0;
        this.knockbackResist = data.knockbackResist || 0;
        this.attackRange = data.attackRange || 0;
        this.isRanged = data.isRanged || false;
        this.color = data.color;
        this.pushX = 0;
        this.pushY = 0;
        // Debuff tracking
        this.poisonDamage = 0;
        this.poisonDuration = 0;
        this.slowMultiplier = 1;
        this.slowDuration = 0;
    }

    update(dt, player) {
        // Apply pushback decay
        this.x += this.pushX * dt;
        this.y += this.pushY * dt;
        this.pushX *= 0.9;
        this.pushY *= 0.9;
        
        // Update poison DoT
        if (this.poisonDuration > 0) {
            this.poisonDuration -= dt;
            // Poison deals 2% max HP per second
            const poisonTickDamage = this.maxHp * 0.02;
            this.hp -= poisonTickDamage;
            if (this.hp <= 0) {
                this.poisonDuration = 0;
                this.poisonDamage = 0;
                return player ? Math.sqrt((player.x - this.x) ** 2 + (player.y - this.y) ** 2) : 0;
            }
            if (this.poisonDuration <= 0) {
                this.poisonDamage = 0;
            }
        }
        
        // Update slow effect
        if (this.slowDuration > 0) {
            this.slowDuration -= dt;
            if (this.slowDuration <= 0) {
                this.slowMultiplier = 1;
            }
        }

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distSqr = dx * dx + dy * dy;
        const dist = Math.sqrt(distSqr);

        // Early exit for enemies very far from player (>1500 units)
        // Skip movement and attack logic to save CPU
        if (distSqr > 2250000) { // 1500^2
            return dist;
        }

        if (this.isRanged) {
            // Ranged enemy: maintain distance
            const desiredDist = this.attackRange * 0.7;
            if (dist < desiredDist) {
                // Move away
                this.x -= (dx / dist) * this.speed * this.slowMultiplier * dt;
                this.y -= (dy / dist) * this.speed * this.slowMultiplier * dt;
            } else if (dist > this.attackRange) {
                // Move closer
                this.x += (dx / dist) * this.speed * this.slowMultiplier * dt;
                this.y += (dy / dist) * this.speed * this.slowMultiplier * dt;
            }
        } else {
            // Melee enemy: move toward player
            if (dist > 0) {
                this.x += (dx / dist) * this.speed * this.slowMultiplier * dt;
                this.y += (dy / dist) * this.speed * this.slowMultiplier * dt;
            }
        }

        // Attack cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= dt;
        }

        return dist;
    }

    applyPoison(duration) {
        this.poisonDuration = duration;
    }
    
    applySlow(multiplier, duration) {
        this.slowMultiplier = Math.max(0.1, multiplier);
        this.slowDuration = duration;
    }

    takeDamage(amount, knockbackX, knockbackY) {
        this.hp -= amount;
        const kbMultiplier = 1 - this.knockbackResist;
        this.pushX = knockbackX * kbMultiplier;
        this.pushY = knockbackY * kbMultiplier;
        return this.hp <= 0;
    }
}

class Projectile {
    constructor() {
        this.active = false;
    }

    init(x, y, vx, vy, damage, owner, config) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.damage = damage;
        this.owner = owner; // 'player' or 'enemy'
        this.pierce = config.pierce || 0;
        this.lifetime = config.lifetime || 5;
        this.homing = config.homing || false;
        this.target = null;
        this.speed = config.speed || 400;
        this.radius = config.radius || 5;
        this.color = config.color || '#fff';
        this.hitEnemies = new Set();
        this.isExplosive = config.isExplosive || false;
        this.explosionRadius = config.explosionRadius || 0;
        this.critChance = config.critChance || 0;
        // Weapon type for SVG rendering
        this.weaponType = config.weaponType || null;
        // Special weapon properties
        this.isIceShard = config.isIceShard || false;
        this.isSacredCross = config.isSacredCross || false;
        this.isPoisonDagger = config.isPoisonDagger || false;
        this.isSpinBlade = config.isSpinBlade || false;
        this.isSoulOrb = config.isSoulOrb || false;
        this.isBoneSpear = config.isBoneSpear || false;
        this.isBloodMoonChakram = config.isBloodMoonChakram || false;
        this.isVampireDagger = config.isVampireDagger || false;
        this.isBatSwarm = config.isBatSwarm || false;
        this.lifesteal = config.lifesteal || 0;
        this.lifestealHeal = config.lifestealHeal || 0;
        this.explosionDamage = config.explosionDamage || 0;
        this.hasExploded = config.hasExploded || false;
        this.orbitAngle = config.orbitAngle || 0;
        this.orbitSpeed = config.orbitSpeed || 0;
        this.orbitRadius = config.orbitRadius || 0;
        this.orbitCenterX = config.orbitCenterX || 0;
        this.orbitCenterY = config.orbitCenterY || 0;
        this.returnTime = config.returnTime || 0;
        this.returnSpeed = config.returnSpeed || 0;
        this.isReturning = false;
        this.hitClearTimer = config.hitClearTimer || 0;
    }

    reset() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.damage = 0;
        this.owner = 'player';
        this.pierce = 0;
        this.lifetime = 0;
        this.homing = false;
        this.target = null;
        this.speed = 400;
        this.radius = 5;
        this.color = '#fff';
        this.hitEnemies.clear();
        this.isExplosive = false;
        this.explosionRadius = 0;
        this.critChance = 0;
        this.weaponType = null;
        this.isIceShard = false;
        this.isSacredCross = false;
        this.isPoisonDagger = false;
        this.isSpinBlade = false;
        this.isSoulOrb = false;
        this.isBoneSpear = false;
        this.isBloodMoonChakram = false;
        this.isVampireDagger = false;
        this.isBatSwarm = false;
        this.lifesteal = 0;
        this.lifestealHeal = 0;
        this.explosionDamage = 0;
        this.hasExploded = false;
        this.orbitAngle = 0;
        this.orbitSpeed = 0;
        this.orbitRadius = 0;
        this.orbitCenterX = 0;
        this.orbitCenterY = 0;
        this.returnTime = 0;
        this.returnSpeed = 0;
        this.isReturning = false;
        this.hitClearTimer = 0;
    }

    update(dt, player, enemies, game) {
        // Handle Soul Orb orbit behavior
        if (this.isSoulOrb) {
            this.orbitAngle += this.orbitSpeed * dt;
            this.x = player.x + Math.cos(this.orbitAngle) * this.orbitRadius;
            this.y = player.y + Math.sin(this.orbitAngle) * this.orbitRadius;
            this.lifetime -= dt;

            // Check collision with enemies - explode on first hit
            const enemyLen = enemies.length;
            for (let i = 0; i < enemyLen; i++) {
                const enemy = enemies[i];
                if (this.hasExploded) break; // Already exploded

                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distSq = dx * dx + dy * dy;
                const combinedRadiusSq = (enemy.radius + this.radius) * (enemy.radius + this.radius);

                if (distSq < combinedRadiusSq && !this.hasExploded) {
                    // Explode on enemy - deal explosion damage
                    const explosionDmg = this.damage * this.explosionDamage;
                    enemy.takeDamage(explosionDmg, 0, 0);
                    if (game && game.damageNumbers) {
                        game.damageNumbers.add(enemy.x, enemy.y - 20, Math.round(explosionDmg), true);
                    }
                    
                    // Create explosion particles
                    if (game && game.particles) {
                        for (let p = 0; p < 8; p++) {
                            const angle = (Math.PI * 2 / 8) * p;
                            const dist = 20;
                            game.particles.emit(
                                this.x + Math.cos(angle) * dist,
                                this.y + Math.sin(angle) * dist,
                                { color: '#9370db', size: 4, life: 0.5, type: 'circle', vy: -30 }
                            );
                        }
                    }
                    
                    this.hasExploded = true;
                    this.lifetime = 0; // Mark for removal
                    break;
                }
            }

            // Emit soul particles while orbiting
            if (!this.hasExploded && game && game.particles && Math.random() < 0.15) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 10;
                game.particles.emit(
                    this.x + Math.cos(angle) * dist,
                    this.y + Math.sin(angle) * dist,
                    { color: '#9370db', size: 2, life: 0.4, type: 'circle' }
                );
            }

            return this.lifetime > 0 && this.active;
        }

        // Handle Blood Moon Chakram return behavior
        if (this.isBloodMoonChakram) {
            this.returnTime -= dt;
            if (this.returnTime <= 0 && !this.isReturning) {
                this.isReturning = true;
                this.hitEnemies.clear();
            }

            if (this.isReturning) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) {
                    this.vx = (dx / dist) * this.returnSpeed;
                    this.vy = (dy / dist) * this.returnSpeed;
                } else {
                    this.lifetime = 0;
                }
            }
        }

        // Handle Vampire Dagger lifesteal
        if (this.isVampireDagger && this.lifesteal > 0) {
            // Lifesteal is applied in collision check below
        }

        // Handle Sacred Cross orbit behavior
        if (this.isSacredCross) {
            this.orbitAngle += this.orbitSpeed * dt;
            this.x = player.x + Math.cos(this.orbitAngle) * this.orbitRadius;
            this.y = player.y + Math.sin(this.orbitAngle) * this.orbitRadius;
            this.lifetime -= dt;

            // Clear hitEnemies periodically so cross can damage enemies multiple times
            this.hitClearTimer -= dt;
            if (this.hitClearTimer <= 0) {
                this.hitEnemies.clear();
                this.hitClearTimer = 0.5; // Clear every 0.5 seconds
            }

            // Check collision with enemies while orbiting
            // OPTIMIZATION: Cache array length and use squared distance
            const enemyLen = enemies.length;
            const combinedRadius = this.radius; // Enemy radius added in comparison
            for (let i = 0; i < enemyLen; i++) {
                const enemy = enemies[i];
                if (this.hitEnemies.has(enemy)) continue;

                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distSq = dx * dx + dy * dy;
                const combinedRadiusSq = (enemy.radius + combinedRadius) * (enemy.radius + combinedRadius);

                if (distSq < combinedRadiusSq) {
                    const dead = enemy.takeDamage(this.damage, 0, 0);
                    if (game && game.damageNumbers) {
                        game.damageNumbers.add(enemy.x, enemy.y - 20, this.damage);
                    }
                    this.hitEnemies.add(enemy);

                    if (dead) {
                        // Enemy will be killed by game loop
                    }

                    // Cross pierces all enemies
                    break;
                }
            }

            // Emit holy particles while orbiting
            if (game && game.particles && Math.random() < 0.15) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 15;
                game.particles.emit(
                    this.x + Math.cos(angle) * dist,
                    this.y + Math.sin(angle) * dist,
                    { color: '#fbbf24', size: 3, life: 0.3, type: 'square' }
                );
            }

            return this.lifetime > 0 && this.active;
        }

        // Handle Spin Blade return behavior
        if (this.isSpinBlade) {
            this.returnTime -= dt;
            if (this.returnTime <= 0 && !this.isReturning) {
                this.isReturning = true;
                // Clear hit enemies so blade can hit again on return
                this.hitEnemies.clear();
            }

            if (this.isReturning) {
                // Return to player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) {
                    this.vx = (dx / dist) * this.returnSpeed;
                    this.vy = (dy / dist) * this.returnSpeed;
                } else {
                    // Reached player, end lifetime
                    this.lifetime = 0;
                }
            }
        }

        if (this.homing && !this.target) {
            // Find target
            // OPTIMIZATION: Cache array length and use squared distance
            let minDistSq = Infinity;
            const enemyLen = enemies.length;
            for (let i = 0; i < enemyLen; i++) {
                const enemy = enemies[i];
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < minDistSq && distSq < 250000) { // 500^2
                    minDistSq = distSq;
                    this.target = enemy;
                }
            }
        }

        if (this.homing && this.target) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
                this.vx = (dx / dist) * this.speed;
                this.vy = (dy / dist) * this.speed;
            }

            if (this.target.hp <= 0) {
                this.target = null;
            }
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.lifetime -= dt;
        
        return this.lifetime > 0 && this.active;
    }
}

class XpGem {
    constructor(x, y, value) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = 8 + value * 0.5;
        this.color = this.getColor();
        this.magnetized = false;
        this.lifetime = 5; // XP gems disappear after 5 seconds
        this.maxLifetime = 5;
    }

    getColor() {
        if (this.value >= 50) return '#ffd700'; // Gold
        if (this.value >= 10) return '#ff4444'; // Red
        if (this.value >= 5) return '#44ff44'; // Green
        return '#4488ff'; // Blue
    }

    // OPTIMIZATION: Use squared distance for range checks
    update(dt, player) {
        // Decrease lifetime
        this.lifetime -= dt;
        
        // Return false if expired (will be removed by game loop)
        if (this.lifetime <= 0) {
            return false;
        }

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distSq = dx * dx + dy * dy;

        const magnetRange = 100 * (1 + (player.passives.goldMagnet || 0));
        const magnetRangeSq = magnetRange * magnetRange;

        // OPTIMIZATION: Use squared distance for magnet check
        if (distSq < magnetRangeSq) {
            this.magnetized = true;
        }

        if (this.magnetized) {
            const speed = 400;
            // Need actual distance for normalization
            const dist = Math.sqrt(distSq);
            if (dist > 0) {
                this.x += (dx / dist) * speed * dt;
                this.y += (dy / dist) * speed * dt;
            }

            // Recalculate distance after movement
            const collectDx = player.x - this.x;
            const collectDy = player.y - this.y;
            const collectDistSq = collectDx * collectDx + collectDy * collectDy;
            const combinedRadius = player.radius + this.radius;

            // OPTIMIZATION: Use squared distance for collection check
            if (collectDistSq < combinedRadius * combinedRadius) {
                return true;
            }
            return false;
        }
        // OPTIMIZATION: Use squared distance for initial collection check
        const combinedRadius = player.radius + this.radius;
        if (distSq < combinedRadius * combinedRadius) {
            return true;
        }
        return false;
    }
}

class HealthPack {
    constructor(x, y, healPercent) {
        this.x = x;
        this.y = y;
        this.healPercent = healPercent;
        this.radius = 12;
        this.magnetized = false;
        this.bobOffset = Math.random() * Math.PI * 2;
    }

    update(dt, player) {
        // Bob animation
        this.bobOffset += dt * 3;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distSq = dx * dx + dy * dy;

        const magnetRange = 100 * (1 + (player.passives.goldMagnet || 0));
        const magnetRangeSq = magnetRange * magnetRange;

        if (distSq < magnetRangeSq) {
            this.magnetized = true;
        }

        if (this.magnetized) {
            const speed = 350;
            const dist = Math.sqrt(distSq);
            if (dist > 0) {
                this.x += (dx / dist) * speed * dt;
                this.y += (dy / dist) * speed * dt;
            }

            const collectDx = player.x - this.x;
            const collectDy = player.y - this.y;
            const collectDistSq = collectDx * collectDx + collectDy * collectDy;
            const combinedRadius = player.radius + this.radius;

            if (collectDistSq < combinedRadius * combinedRadius) {
                return true;
            }
            return false;
        }

        const combinedRadius = player.radius + this.radius;
        if (distSq < combinedRadius * combinedRadius) {
            return true;
        }
        return false;
    }
}

// ==================== GROUND EFFECT CLASS ====================
class GroundEffect {
    constructor(x, y, radius, duration, damage, tickRate, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.duration = duration;
        this.maxDuration = duration;
        this.damage = damage;
        this.tickRate = tickRate;
        this.tickCooldown = 0;
        this.color = color;
        this.hitEnemies = new Set();
    }
    
    update(dt) {
        this.duration -= dt;
        if (this.tickCooldown > 0) {
            this.tickCooldown -= dt;
        }
        return this.duration > 0;
    }
}

// ==================== MAIN GAME CLASS ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();

        this.input = new InputHandler();
        this.particles = new ParticleSystem();
        this.damageNumbers = new DamageNumberSystem();
        this.spatialHash = new SpatialHash(100);

        this.player = null;
        this.enemies = [];
        this.projectiles = [];
        this.xpGems = [];
        this.healthPacks = [];
        this.groundEffects = [];
        this.lightningBolts = [];

        this.camera = { x: 0, y: 0 };
        this.gameTime = 0;
        this.wave = 1;
        this.waveTimer = 0;
        this.spawnTimer = 0;
        this.kills = 0;

        this.state = 'start'; // start, playing, paused, levelup, gameover, victory
        this.levelUpPending = false;
        this.pendingLevel = 0;

        // Performance monitoring
        this.frameCount = 0;
        this.fpsTimer = 0;
        this.currentFPS = 60;
        this.updateTime = 0;
        this.renderTime = 0;

        // Special Event State
        this.activeEvents = {
            bloodMoon: false,
            treasureWave: false
        };
        this.bloodMoonTimer = 0;
        this.eventNotifications = [];

        this.saveData = this.loadSave();

        // Mobile touch controls
        this.joystick = null;
        this.isMobile = this.detectMobile();
        this.pauseButton = document.getElementById('pauseButton');
        this.pauseIcon = document.getElementById('pauseIcon');
        this.playIcon = document.getElementById('playIcon');

        this.setupMobileControls();

        window.addEventListener('resize', () => this.resize());
    }

    detectMobile() {
        return 'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 ||
               window.innerWidth <= 768;
    }

    setupMobileControls() {
        // Initialize virtual joystick for mobile devices
        if (this.isMobile) {
            const joystickContainer = document.getElementById('virtualJoystick');
            this.joystick = new VirtualJoystick(joystickContainer);
            
            // Add mobile-ui class to body for CSS
            document.body.classList.add('mobile-ui');
        }

        // Setup pause button
        if (this.pauseButton) {
            this.pauseButton.addEventListener('click', () => this.togglePause());
            this.pauseButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.togglePause();
            }, { passive: false });
        }

        // Prevent default touch behaviors on the entire document
        document.addEventListener('touchmove', (e) => {
            // Allow touch movement only if it's on the joystick
            if (this.joystick && this.joystick.active) {
                return;
            }
            // Prevent scrolling when touching the game area
            if (e.target === this.canvas || e.target.closest('#gameCanvas')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Prevent double-tap zoom
        document.addEventListener('dblclick', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Prevent context menu on long press
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    loadSave() {
        try {
            const data = localStorage.getItem('shadowSurvivorSave');
            if (data) {
                return JSON.parse(data);
            }
        } catch (e) {
            console.error('Failed to load save:', e);
        }
        return {
            unlockedWeapons: ['magicWand'],
            unlockedPassives: [],
            permanentUpgrades: {},
            stats: {
                totalPlayTime: 0,
                totalKills: 0,
                highestWave: 0,
                runsCompleted: 0
            }
        };
    }
    
    saveGame() {
        try {
            localStorage.setItem('shadowSurvivorSave', JSON.stringify(this.saveData));
        } catch (e) {
            console.error('Failed to save:', e);
        }
    }
    
    start() {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('weaponSelectScreen').style.display = 'flex';
        this.showWeaponSelection();
    }

    showWeaponSelection() {
        const container = document.getElementById('weaponSelectCards');
        container.innerHTML = '';
        
        // Show first 6 weapons (or all if less than 6)
        const weaponIds = Object.keys(WEAPONS).slice(0, 6);
        
        for (const weaponId of weaponIds) {
            const weapon = WEAPONS[weaponId];
            const card = document.createElement('div');
            card.className = 'weapon-select-card';
            card.innerHTML = `
                <div class="weapon-select-icon">${weapon.icon}</div>
                <div class="weapon-select-name">${weapon.name}</div>
                <div class="weapon-select-description">${weapon.description}</div>
            `;
            card.onclick = () => this.selectStartingWeapon(weaponId);
            container.appendChild(card);
        }
    }

    selectStartingWeapon(weaponId) {
        document.getElementById('weaponSelectScreen').style.display = 'none';
        this.initGame(weaponId);
        this.state = 'playing';
        this.lastTime = performance.now();

        // Reset joystick state
        if (this.joystick) {
            this.joystick.setActive(false);
        }
        this.input.resetJoystick();

        requestAnimationFrame(() => this.gameLoop());
    }
    
    initGame(selectedWeaponId = 'magicWand') {
        this.player = new Player();

        // Give selected starting weapon (defaults to Magic Wand)
        this.player.weapons.push(this.createWeapon(selectedWeaponId));

        this.enemies = [];
        this.projectiles = [];
        this.xpGems = [];
        this.healthPacks = [];
        this.groundEffects = [];
        this.lightningBolts = [];
        this.decorations = [];
        this.gameTime = 0;
        this.wave = 1;
        this.waveTimer = 0;
        this.spawnTimer = 0;
        this.kills = 0;
        this.levelUpPending = false;
        this.waveNotifications = [];

        // Reset event state
        this.activeEvents = {
            bloodMoon: false,
            treasureWave: false
        };
        this.bloodMoonTimer = 0;
        this.eventNotifications = [];

        // Generate map decorations
        this.generateDecorations();

        // Setup projectile pool with proper reset function
        this.projectilePool = new ObjectPool(
            () => new Projectile(),
            (p) => p.reset()
        );

        this.updateUI();
        this.updateWeaponBar();
    }
    
    createWeapon(weaponId) {
        const data = WEAPONS[weaponId];
        const weapon = {
            ...data,
            level: 1,
            currentCooldown: 0,
            damage: data.baseDamage,
            range: data.baseRange,
            projectileCount: data.projectileCount || 0,
            pierce: data.pierce || 0,
            critChance: data.critChance || 0,
            explosionRadius: data.explosionRadius || 0,
            chainCount: data.chainCount || 0,
            chainRange: data.chainRange || 0,
            poolDuration: data.poolDuration || 0,
            poolRadius: data.poolRadius || 0,
            tickRate: data.tickRate || 0,
        };

        // Initialize Sacred Cross specific properties
        if (weaponId === 'sacredCross') {
            weapon.sacredCrossActive = false;
            weapon.sacredCrossTimer = 0; // Ready to spawn immediately
        }

        return weapon;
    }

    togglePause() {
        if (this.state === 'playing') {
            this.state = 'paused';
            document.getElementById('pauseScreen').style.display = 'flex';
            this.updatePauseButtonIcon(true);
        } else if (this.state === 'paused') {
            this.state = 'playing';
            document.getElementById('pauseScreen').style.display = 'none';
            this.updatePauseButtonIcon(false);
            this.lastTime = performance.now();
            requestAnimationFrame(() => this.gameLoop());
        }
    }

    updatePauseButtonIcon(isPaused) {
        if (this.pauseIcon && this.playIcon) {
            if (isPaused) {
                this.pauseIcon.style.display = 'none';
                this.playIcon.style.display = 'block';
            } else {
                this.pauseIcon.style.display = 'block';
                this.playIcon.style.display = 'none';
            }
        }
    }

    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('levelUpScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'flex';
        this.state = 'start';
        this.saveData = this.loadSave();
        this.updatePauseButtonIcon(false);
    }
    
    gameLoop() {
        if (this.state !== 'playing' && this.state !== 'levelup') return;

        const now = performance.now();
        const dt = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;

        // FPS counter (log only when drops below 30)
        this.frameCount = (this.frameCount || 0) + 1;
        if (!this.fpsTimer) this.fpsTimer = 0;
        this.fpsTimer += dt;
        if (this.fpsTimer >= 1) {
            this.currentFPS = Math.round(this.frameCount / this.fpsTimer);
            this.frameCount = 0;
            this.fpsTimer = 0;
            if (this.currentFPS < 30) {
                console.warn('[FPS] Low:', this.currentFPS);
            }
        }

        if (this.state === 'playing') {
            this.update(dt);
        }
        this.render();

        if (this.state === 'playing' || this.state === 'levelup') {
            requestAnimationFrame(() => this.gameLoop());
        }
    }
    
    update(dt) {
        this.gameTime += dt;
        this.waveTimer += dt;

        // Update Blood Moon event timer
        if (this.activeEvents.bloodMoon) {
            this.bloodMoonTimer -= dt;
            if (this.bloodMoonTimer <= 0) {
                this.activeEvents.bloodMoon = false;
                this.showEventNotification('BLOOD MOON ENDED', '#ef4444');
            }
        }

        // Wave progression
        if (this.waveTimer >= CONFIG.WAVE_DURATION) {
            this.wave++;
            this.waveTimer = 0;
            this.showWaveNotification();
            this.checkAndTriggerEvents();
        }

        // Check victory
        if (this.gameTime >= CONFIG.GAME_DURATION) {
            this.victory();
            return;
        }

        // Update player
        this.player.update(dt, this.input);
        
        // Update camera with clamped target position
        const targetCamX = this.player.x - CONFIG.CANVAS_WIDTH / 2;
        const targetCamY = this.player.y - CONFIG.CANVAS_HEIGHT / 2;
        const clampedTargetX = Math.max(0, Math.min(CONFIG.MAP_BOUNDS.width - CONFIG.CANVAS_WIDTH, targetCamX));
        const clampedTargetY = Math.max(0, Math.min(CONFIG.MAP_BOUNDS.height - CONFIG.CANVAS_HEIGHT, targetCamY));
        
        this.camera.x += (clampedTargetX - this.camera.x) * CONFIG.CAMERA_SMOOTHING;
        this.camera.y += (clampedTargetY - this.camera.y) * CONFIG.CAMERA_SMOOTHING;
        
        // Spawn enemies
        this.updateSpawning(dt);
        
        // Update weapons
        this.updateWeapons(dt);
        
        // Update enemies
        this.updateEnemies(dt);
        
        // Update projectiles
        this.updateProjectiles(dt);

        // Update lightning bolts
        this.updateLightningBolts(dt);

        // Update ground effects
        this.updateGroundEffects(dt);
        
        // Update XP gems
        this.updateXpGems(dt);

        // Update health packs
        this.updateHealthPacks(dt);

        // Update particles
        this.particles.update(dt);
        
        // Update damage numbers
        this.damageNumbers.update(dt);
        
        // Update UI
        this.updateUI();
    }
    
    updateSpawning(dt) {
        let spawnInterval = Math.max(
            CONFIG.SPAWN_MIN_INTERVAL,
            CONFIG.SPAWN_BASE_INTERVAL * Math.pow(0.95, this.wave - 1)
        );
        
        // Blood Moon doubles spawn rate (halves interval)
        if (this.activeEvents.bloodMoon) {
            spawnInterval *= CONFIG.BLOOD_MOON_SPAWN_MULTIPLIER;
        }

        this.spawnTimer += dt;
        if (this.spawnTimer >= spawnInterval) {
            this.spawnTimer = 0;
            this.spawnEnemy();
        }
    }
    
    spawnEnemy(siegeMode = false) {
        // ENFORCEMENT: Check enemy limit before spawning
        if (this.enemies.length >= CONFIG.MAX_ENEMIES) {
            this.spawnTimer = 0;
            return;
        }

        // Determine enemy type based on wave
        const types = this.getAvailableEnemyTypes();
        const weights = this.getEnemyWeights();

        let type = this.weightedRandom(types, weights);
        
        // FIXED: Linear damage/HP scaling instead of exponential
        // Old: Math.pow(2.5, this.wave - 1) = 1, 2.5, 6.25, 15.6, 39, 97... (way too fast)
        // New: 1 + (wave-1) * 0.3 = 1, 1.3, 1.6, 1.9, 2.2, 2.5... (much smoother)
        const waveMultiplier = 1 + (this.wave - 1) * 0.3;

        let x, y;

        if (siegeMode) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 300 + Math.random() * 100;
            x = this.player.x + Math.cos(angle) * distance;
            y = this.player.y + Math.sin(angle) * distance;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.max(CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT) / 2 + 100;
            x = this.player.x + Math.cos(angle) * distance;
            y = this.player.y + Math.sin(angle) * distance;
        }

        const clampedX = Math.max(50, Math.min(CONFIG.MAP_BOUNDS.width - 50, x));
        const clampedY = Math.max(50, Math.min(CONFIG.MAP_BOUNDS.height - 50, y));

        const enemy = new Enemy(type, clampedX, clampedY, waveMultiplier);

        if (this.activeEvents.bloodMoon) {
            enemy.speed *= CONFIG.BLOOD_MOON_SPEED_MULTIPLIER;
            enemy.damage *= CONFIG.BLOOD_MOON_DAMAGE_MULTIPLIER;
        }

        this.enemies.push(enemy);
    }

    spawnSiegeEnemies() {
        const count = 8 + Math.floor(Math.random() * 5);
        
        if (this.enemies.length >= CONFIG.MAX_ENEMIES) return;
        
        const actualCount = Math.min(count, CONFIG.MAX_ENEMIES - this.enemies.length);
        if (actualCount <= 0) return;
        
        const types = this.getAvailableEnemyTypes();
        const weights = this.getEnemyWeights();

        for (let i = 0; i < actualCount; i++) {
            const type = this.weightedRandom(types, weights);
            // FIXED: Use same linear scaling as spawnEnemy
            const waveMultiplier = 1 + (this.wave - 1) * 0.3;

            const angle = (Math.PI * 2 / count) * i + Math.random() * 0.3;
            const distance = 350 + Math.random() * 50;
            const x = this.player.x + Math.cos(angle) * distance;
            const y = this.player.y + Math.sin(angle) * distance;

            const clampedX = Math.max(50, Math.min(CONFIG.MAP_BOUNDS.width - 50, x));
            const clampedY = Math.max(50, Math.min(CONFIG.MAP_BOUNDS.height - 50, y));

            const enemy = new Enemy(type, clampedX, clampedY, waveMultiplier);
            
            // Apply Blood Moon buffs if active
            if (this.activeEvents.bloodMoon) {
                enemy.speed *= CONFIG.BLOOD_MOON_SPEED_MULTIPLIER;
                enemy.damage *= CONFIG.BLOOD_MOON_DAMAGE_MULTIPLIER;
            }
            
            this.enemies.push(enemy);
        }
    }
    
    getAvailableEnemyTypes() {
        const types = ['zombie'];
        if (this.wave >= 2) types.push('ghoul');
        if (this.wave >= 3) types.push('demonImp');
        if (this.wave >= 4) types.push('skeleton');
        if (this.wave >= 4) types.push('shadowStalker');
        if (this.wave >= 5) types.push('witch');
        if (this.wave >= 5) types.push('plagueBats');
        if (this.wave >= 5) types.push('cryptWraith'); // NEW
        if (this.wave >= 6) types.push('cursedKnight');
        if (this.wave >= 6) types.push('berserkerMutant'); // NEW
        if (this.wave >= 7) types.push('necromancer');
        if (this.wave >= 8) types.push('darkPriest'); // NEW
        if (this.wave >= 9) types.push('crystalGolem'); // NEW
        if (this.wave >= 10) types.push('voidReaper');
        return types;
    }

    getEnemyWeights() {
        const weights = [50]; // zombie
        if (this.wave >= 2) weights.push(25); // ghoul
        if (this.wave >= 3) weights.push(20); // demonImp
        if (this.wave >= 4) weights.push(15); // skeleton
        if (this.wave >= 4) weights.push(15); // shadowStalker
        if (this.wave >= 5) weights.push(12); // witch
        if (this.wave >= 5) weights.push(15); // plagueBats
        if (this.wave >= 5) weights.push(12); // cryptWraith
        if (this.wave >= 6) weights.push(10); // cursedKnight
        if (this.wave >= 6) weights.push(12); // berserkerMutant
        if (this.wave >= 7) weights.push(8); // necromancer
        if (this.wave >= 8) weights.push(8); // darkPriest
        if (this.wave >= 9) weights.push(6); // crystalGolem
        if (this.wave >= 10) weights.push(2); // voidReaper (rare)

        // Adjust weights based on wave - reduce early enemies as game progresses
        if (this.wave >= 10) {
            weights[0] = Math.max(15, weights[0] - this.wave * 0.5);
        }

        return weights.slice(0, this.getAvailableEnemyTypes().length);
    }
    
    weightedRandom(items, weights) {
        let total = 0;
        for (const w of weights) total += w;

        let random = Math.random() * total;
        for (let i = 0; i < items.length; i++) {
            random -= weights[i];
            if (random <= 0) return items[i];
        }
        return items[0];
    }
    
    /**
     * Check and trigger special events at wave transitions
     */
    checkAndTriggerEvents() {
        // Blood Moon: Every 5 waves, 20% chance
        if (this.wave % CONFIG.BLOOD_MOON_INTERVAL === 0 && Math.random() < CONFIG.BLOOD_MOON_CHANCE) {
            this.triggerBloodMoon();
        }

        // Enemy Siege: Every 3 waves, 30% chance
        if (this.wave % CONFIG.ENEMY_SIEGE_INTERVAL === 0 && Math.random() < CONFIG.ENEMY_SIEGE_CHANCE) {
            this.triggerEnemySiege();
        }

        // Treasure Wave: Every 4 waves, 25% chance
        if (this.wave % CONFIG.TREASURE_WAVE_INTERVAL === 0 && Math.random() < CONFIG.TREASURE_WAVE_CHANCE) {
            this.triggerTreasureWave();
        }

        // Bat Swarm: Every 4 waves, 35% chance - bats fly across screen
        if (this.wave % 4 === 0 && Math.random() < 0.35) {
            this.triggerBatSwarm();
        }

        // BOSS SPAWN: Every 5 waves, guaranteed boss
        if (this.wave % 5 === 0 && this.wave >= 5) {
            this.triggerBossSpawn();
        }
    }
    
    /**
     * Trigger Blood Moon event - red tint, faster spawns, buffed enemies
     */
    triggerBloodMoon() {
        this.activeEvents.bloodMoon = true;
        this.bloodMoonTimer = CONFIG.BLOOD_MOON_DURATION;
        this.showEventNotification('‚ö†Ô∏è BLOOD MOON ‚ö†Ô∏è', '#ef4444');
        
        // Visual effect - blood particles
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 500;
            this.particles.emit(
                this.player.x + Math.cos(angle) * dist,
                this.player.y + Math.sin(angle) * dist,
                { 
                    color: '#7f1d1d', 
                    size: 5 + Math.random() * 5, 
                    life: 1.5,
                    type: 'circle',
                    vy: -30
                }
            );
        }
    }
    
    /**
     * Trigger Enemy Siege event - enemies spawn in circle and charge player
     */
    triggerEnemySiege() {
        this.showEventNotification('üíÄ ENEMY SIEGE üíÄ', '#f97316');
        this.spawnSiegeEnemies();
        
        // Visual effect - warning particles
        for (let i = 0; i < 30; i++) {
            const angle = (Math.PI * 2 / 30) * i;
            const dist = 350;
            this.particles.emit(
                this.player.x + Math.cos(angle) * dist,
                this.player.y + Math.sin(angle) * dist,
                { 
                    color: '#f97316', 
                    size: 8, 
                    life: 1.0,
                    type: 'square'
                }
            );
        }
    }
    
    /**
     * Trigger Treasure Wave event - extra XP from enemies
     */
    triggerTreasureWave() {
        this.activeEvents.treasureWave = true;
        this.showEventNotification('üíé TREASURE WAVE üíé', '#fbbf24');

        // Visual effect - gold particles
        for (let i = 0; i < 40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 400;
            this.particles.emit(
                this.player.x + Math.cos(angle) * dist,
                this.player.y + Math.sin(angle) * dist,
                {
                    color: '#fbbf24',
                    size: 4 + Math.random() * 4,
                    life: 1.0,
                    type: 'circle',
                    vy: -50
                }
            );
        }
    }

    /**
     * Trigger Bat Swarm event - bats fly across screen from random direction
     */
    triggerBatSwarm() {
        console.log('[BAT SWARM] Triggering bat swarm at wave', this.wave);
        this.showEventNotification('ü¶á BAT SWARM ü¶á', '#6b8c42');

        // Spawn bats from one side flying to the other
        const numBats = 30 + Math.floor(Math.random() * 20);
        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left

        for (let i = 0; i < numBats; i++) {
            let startX, startY, vx, vy;
            const speed = 200 + Math.random() * 100;
            const offset = (i / numBats) * CONFIG.CANVAS_WIDTH;

            switch (side) {
                case 0: // Top to bottom
                    startX = this.camera.x + offset;
                    startY = this.camera.y - 50;
                    vx = (Math.random() - 0.5) * 50;
                    vy = speed;
                    break;
                case 1: // Right to left
                    startX = this.camera.x + CONFIG.CANVAS_WIDTH + 50;
                    startY = this.camera.y + offset;
                    vx = -speed;
                    vy = (Math.random() - 0.5) * 50;
                    break;
                case 2: // Bottom to top
                    startX = this.camera.x + offset;
                    startY = this.camera.y + CONFIG.CANVAS_HEIGHT + 50;
                    vx = (Math.random() - 0.5) * 50;
                    vy = -speed;
                    break;
                case 3: // Left to right
                    startX = this.camera.x - 50;
                    startY = this.camera.y + offset;
                    vx = speed;
                    vy = (Math.random() - 0.5) * 50;
                    break;
            }

            // Create bat projectile that flies across screen
            const bat = this.projectilePool.get();
            bat.active = true;
            bat.init(
                startX, startY,
                vx, vy,
                5 + this.wave * 0.5, // Small damage
                'enemy',
                {
                    speed: speed,
                    radius: 6,
                    color: '#6b8c42',
                    lifetime: 8,
                    isBatSwarm: true
                }
            );
            this.projectiles.push(bat);
        }

        // Visual effect - bat particles
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 300;
            this.particles.emit(
                this.player.x + Math.cos(angle) * dist,
                this.player.y + Math.sin(angle) * dist,
                {
                    color: '#6b8c42',
                    size: 3 + Math.random() * 3,
                    life: 1.5,
                    type: 'circle',
                    vy: -20
                }
            );
        }
    }

    /**
     * Trigger boss spawn - spawns a powerful boss enemy
     */
    triggerBossSpawn() {
        console.log('[BOSS] Triggering boss spawn at wave', this.wave);
        
        let bossType;

        // Select boss based on wave
        if (this.wave < 10) {
            bossType = 'lordOfBones';
        } else if (this.wave < 15) {
            bossType = 'bloodQueen';
        } else {
            bossType = 'voidLord';
        }

        const bossData = ENEMIES[bossType];
        const waveMultiplier = 1 + (this.wave - 1) * 0.3;

        console.log('[BOSS] Spawning', bossData.name, 'with HP:', bossData.baseHp * waveMultiplier);

        // Spawn boss at player position with offset
        const angle = Math.random() * Math.PI * 2;
        const distance = 400;
        const x = this.player.x + Math.cos(angle) * distance;
        const y = this.player.y + Math.sin(angle) * distance;

        const boss = new Enemy(bossType, x, y, waveMultiplier);

        // Boss-specific enhancements
        boss.isBoss = true;
        boss.specialAbility = bossData.specialAbility;
        boss.abilityCooldown = 0;
        boss.abilityInterval = 3; // Use ability every 3 seconds

        this.enemies.push(boss);

        // Show boss notification
        this.showEventNotification(`‚ö†Ô∏è BOSS: ${bossData.name.toUpperCase()} ‚ö†Ô∏è`, '#ef4444');

        // Visual effect - dramatic particles
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 200;
            this.particles.emit(
                x + Math.cos(angle) * dist,
                y + Math.sin(angle) * dist,
                {
                    color: bossData.color,
                    size: 8 + Math.random() * 8,
                    life: 2.0,
                    type: 'square',
                    vy: -40
                }
            );
        }

        // Screen shake effect
        this.screenShake = 10;
    }

    /**
     * End Treasure Wave event
     */
    endTreasureWave() {
        this.activeEvents.treasureWave = false;
    }
    
    /**
     * Show event notification on screen
     */
    showEventNotification(text, color) {
        this.eventNotifications.push({
            text: text,
            color: color,
            alpha: 1,
            scale: 1.3,
            life: 4, // seconds to display
            yOffset: 0
        });
    }

    // OPTIMIZATION: Cache array length for iteration
    updateWeapons(dt) {
        // Update Sacred Cross cooldown system separately
        this.updateSacredCrossWeapons(dt);

        const len = this.player.weapons.length;
        for (let i = 0; i < len; i++) {
            const weapon = this.player.weapons[i];
            // Sacred Cross uses its own cooldown system
            if (weapon.id === 'sacredCross') {
                // Only fire if ready (timer >= 0)
                if (weapon.sacredCrossTimer >= 0) {
                    this.fireWeapon(weapon);
                }
                continue;
            }

            if (weapon.currentCooldown > 0) continue;

            const cooldown = weapon.baseCooldown /
                (1 + this.player.attackSpeedMultiplier) /
                (1 - Math.min(0.5, this.player.cooldownReduction));

            // Minimum cooldown floor of 0.05s to prevent negative cooldowns
            weapon.currentCooldown = Math.max(0.05, cooldown);
            this.fireWeapon(weapon);
        }
    }
    
    fireWeapon(weapon) {
        const player = this.player;
        const damage = weapon.damage * player.damageMultiplier;
        const range = weapon.range * player.areaMultiplier;
        
        switch (weapon.id) {
            case 'magicAura':
                this.fireMagicAura(weapon, damage, range);
                break;
            case 'fireballArc':
                this.fireFireball(weapon, damage, range);
                break;
            case 'magicWand':
                this.fireMagicWand(weapon, damage, range);
                break;
            case 'throwingKnife':
                this.fireThrowingKnife(weapon, damage, range);
                break;
            case 'lightningBolt':
                this.fireLightning(weapon, damage, range);
                break;
            case 'holyWater':
                this.fireHolyWater(weapon, damage, range);
                break;
            case 'iceShard':
                this.fireIceShard(weapon, damage, range);
                break;
            case 'sacredCross':
                this.fireSacredCross(weapon, damage, range);
                break;
            case 'poisonDagger':
                this.firePoisonDagger(weapon, damage, range);
                break;
            case 'spinBlade':
                this.fireSpinBlade(weapon, damage, range);
                break;
            case 'soulOrb':
                this.fireSoulOrb(weapon, damage, range);
                break;
            case 'boneSpear':
                this.fireBoneSpear(weapon, damage, range);
                break;
            case 'bloodMoonChakram':
                this.fireBloodMoonChakram(weapon, damage, range);
                break;
            case 'vampireDagger':
                this.fireVampireDagger(weapon, damage, range);
                break;
        }
    }

    fireMagicAura(weapon, damage, range) {
        // Damage all enemies in radius - tick damage is per tick
        const tickDamage = damage;
        const effectiveRange = range * this.player.areaMultiplier;
        // OPTIMIZATION: Pre-calculate squared range for comparison
        const effectiveRangeSq = effectiveRange * effectiveRange;

        // Create a copy of enemies array to avoid modification during iteration
        const enemiesToProcess = [...this.enemies];
        const enemiesToKill = [];

        // OPTIMIZATION: Cache array length
        const len = enemiesToProcess.length;
        for (let i = 0; i < len; i++) {
            const enemy = enemiesToProcess[i];
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            // OPTIMIZATION: Use squared distance instead of Math.sqrt
            const distSq = dx * dx + dy * dy;
            // Compare with squared range (account for enemy radius)
            const rangeWithRadius = effectiveRange + enemy.radius;
            if (distSq <= rangeWithRadius * rangeWithRadius) {
                const dead = enemy.takeDamage(tickDamage, 0, 0);
                this.damageNumbers.add(enemy.x, enemy.y - 20, tickDamage);

                if (dead) {
                    enemiesToKill.push(enemy);
                }
            }
        }

        // Kill enemies after processing all damage
        const killLen = enemiesToKill.length;
        for (let i = 0; i < killLen; i++) {
            this.killEnemy(enemiesToKill[i]);
        }

        // Visual effect
        for (let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * effectiveRange;
            this.particles.emit(
                this.player.x + Math.cos(angle) * dist,
                this.player.y + Math.sin(angle) * dist,
                { color: '#a855f7', size: 3 + Math.random() * 3, life: 0.3, type: 'circle' }
            );
        }
    }
    
    fireFireball(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        
        for (let i = 0; i < count; i++) {
            const target = this.findNearestEnemy(range);
            if (!target) continue;
            
            const dx = target.x - this.player.x;
            const dy = target.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                const vx = (dx / dist) * weapon.projectileSpeed;
                const vy = (dy / dist) * weapon.projectileSpeed;
                
                const proj = this.projectilePool.get();
                proj.active = true;
                proj.init(
                    this.player.x, this.player.y,
                    vx, vy,
                    damage,
                    'player',
                    {
                        speed: weapon.projectileSpeed,
                        radius: 8,
                        color: '#ff6b35',
                        pierce: 999, // Pierces all
                        lifetime: 2,
                        weaponType: 'fireball_arc'
                    }
                );
                proj.explosionRadius = weapon.explosionRadius * this.player.areaMultiplier;
                proj.isExplosive = true;
                this.projectiles.push(proj);
            }
        }
    }
    
    fireMagicWand(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        
        for (let i = 0; i < count; i++) {
            const target = this.findNearestEnemy(range);
            if (!target) continue;
            
            const dx = target.x - this.player.x;
            const dy = target.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const speed = weapon.projectileSpeed;
            const vx = dist > 0 ? (dx / dist) * speed : speed;
            const vy = dist > 0 ? (dy / dist) * speed : 0;
            
            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    homing: true,
                    speed: speed,
                    radius: 6,
                    color: '#4299e1',
                    pierce: weapon.pierce,
                    lifetime: 5,
                    weaponType: 'magic_wand'
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireThrowingKnife(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        let facing = { ...this.player.facing };
        
        // Default to right if no direction
        if (facing.x === 0 && facing.y === 0) {
            facing.x = 1;
        }
        
        for (let i = 0; i < count; i++) {
            const spreadAngle = (i - (count - 1) / 2) * 0.15;
            const cos = Math.cos(spreadAngle);
            const sin = Math.sin(spreadAngle);
            
            const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
            const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;
            
            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 4,
                    color: '#ffd700',
                    pierce: 1,
                    lifetime: 2,
                    critChance: weapon.critChance,
                    weaponType: 'throwing_knife'
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireLightning(weapon, damage, range) {
        const target = this.findNearestEnemy(range);
        if (!target) return;

        let currentTarget = target;
        let chainCount = 0;
        let chainOrigins = []; // Store origin points for lightning bolts
        const visited = new Set();

        while (currentTarget && chainCount < weapon.chainCount) {
            visited.add(currentTarget);

            // Store origin point for this chain link
            const origin = chainCount === 0 ? 
                { x: this.player.x, y: this.player.y } : 
                { x: currentTarget.x, y: currentTarget.y };
            
            // Deal damage
            const chainDamage = damage * Math.max(0.5, 1 - chainCount * 0.1);
            const dead = currentTarget.takeDamage(
                chainDamage,
                (currentTarget.x - this.player.x) * 0.01,
                (currentTarget.y - this.player.y) * 0.01
            );

            this.damageNumbers.add(currentTarget.x, currentTarget.y - 20, chainDamage);

            // Store lightning bolt endpoints for rendering
            chainOrigins.push({
                startX: origin.x,
                startY: origin.y,
                endX: currentTarget.x,
                endY: currentTarget.y
            });

            // Lightning visual - particles at impact
            for (let i = 0; i < 5; i++) {
                this.particles.emit(
                    currentTarget.x + (Math.random() - 0.5) * 40,
                    currentTarget.y + (Math.random() - 0.5) * 40,
                    { color: '#fbbf24', size: 4, life: 0.3, type: 'square' }
                );
            }

            if (dead) {
                this.killEnemy(currentTarget);
                break;
            }

            // Find next chain target
            let nextTarget = null;
            let minDistSq = Infinity;
            const chainRangeSq = weapon.chainRange * weapon.chainRange;

            // OPTIMIZATION: Cache array length and use squared distance
            const enemyLen = this.enemies.length;
            for (let i = 0; i < enemyLen; i++) {
                const enemy = this.enemies[i];
                if (visited.has(enemy)) continue;

                const dx = enemy.x - currentTarget.x;
                const dy = enemy.y - currentTarget.y;
                const distSq = dx * dx + dy * dy;

                if (distSq < chainRangeSq && distSq < minDistSq) {
                    minDistSq = distSq;
                    nextTarget = enemy;
                }
            }

            currentTarget = nextTarget;
            chainCount++;
        }

        // Create lightning bolt visual effects
        const chainLen = chainOrigins.length;
        for (let i = 0; i < chainLen; i++) {
            const bolt = chainOrigins[i];
            this.createLightningBolt(bolt.startX, bolt.startY, bolt.endX, bolt.endY);
        }
    }

    createLightningBolt(startX, startY, endX, endY) {
        // Create a temporary lightning bolt effect
        const bolt = {
            startX: startX,
            startY: startY,
            endX: endX,
            endY: endY,
            life: 0.15, // 150ms visible
            maxLife: 0.15,
            segments: []
        };

        // Generate jagged lightning segments
        const dx = endX - startX;
        const dy = endY - startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const segments = Math.floor(dist / 20); // Segment every 20 pixels

        bolt.segments.push({ x: startX, y: startY });
        
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const baseX = startX + dx * t;
            const baseY = startY + dy * t;
            // Add perpendicular offset for jagged effect
            const offset = (Math.random() - 0.5) * 30;
            const perpX = -dy / dist * offset;
            const perpY = dx / dist * offset;
            bolt.segments.push({ x: baseX + perpX, y: baseY + perpY });
        }
        
        bolt.segments.push({ x: endX, y: endY });

        this.lightningBolts.push(bolt);
    }
    
    fireHolyWater(weapon, damage, range) {
        const target = this.findNearestEnemy(range);
        if (!target) return;
        
        // Create pool near enemy
        const offsetX = (Math.random() - 0.5) * 100;
        const offsetY = (Math.random() - 0.5) * 100;
        
        const pool = new GroundEffect(
            target.x + offsetX,
            target.y + offsetY,
            weapon.poolRadius * this.player.areaMultiplier,
            weapon.poolDuration,
            damage,
            weapon.tickRate,
            '#06b6d4'
        );
        
        this.groundEffects.push(pool);
    }

    fireIceShard(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        const target = this.findNearestEnemy(range);
        
        if (!target && count > 0) {
            // If no target, fire in player facing direction
            let facing = { ...this.player.facing };
            if (facing.x === 0 && facing.y === 0) {
                facing.x = 1;
            }
            
            for (let i = 0; i < count; i++) {
                const spreadAngle = (i - (count - 1) / 2) * 0.1;
                const cos = Math.cos(spreadAngle);
                const sin = Math.sin(spreadAngle);
                
                const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
                const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;
                
                const proj = this.projectilePool.get();
                proj.active = true;
                proj.init(
                    this.player.x, this.player.y,
                    vx, vy,
                    damage,
                    'player',
                    {
                        speed: weapon.projectileSpeed,
                        radius: 5,
                        color: '#67e8f9',
                        pierce: weapon.pierce,
                        lifetime: 2,
                        isIceShard: true,
                        weaponType: 'ice_shard'
                    }
                );
                this.projectiles.push(proj);
            }
            return;
        }

        for (let i = 0; i < count; i++) {
            const dx = target.x - this.player.x;
            const dy = target.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Add slight spread for multiple projectiles
            const spreadAngle = (i - (count - 1) / 2) * 0.08;
            const cos = Math.cos(spreadAngle);
            const sin = Math.sin(spreadAngle);

            const baseVx = (dx / dist) * weapon.projectileSpeed;
            const baseVy = (dy / dist) * weapon.projectileSpeed;

            const vx = baseVx * cos - baseVy * sin;
            const vy = baseVx * sin + baseVy * cos;

            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 5,
                    color: '#67e8f9',
                    pierce: weapon.pierce,
                    lifetime: 2,
                    isIceShard: true,
                    weaponType: 'ice_shard'
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireSacredCross(weapon, damage, range) {
        // Check if weapon has cooldown tracking
        if (!weapon.sacredCrossActive) {
            weapon.sacredCrossActive = false;
            weapon.sacredCrossTimer = 0;
        }

        // Calculate cross count based on weapon level
        // Level 1: 1 cross, Level 2: 2 crosses, Level 3: 3 crosses, Level 4: 4 crosses, Level 5: 5 crosses, Level 6+: 6 crosses
        let crossCount = Math.min(6, weapon.level);
        
        // After level 6, only damage increases (handled by weapon.damage)
        
        const effectiveRange = range * this.player.areaMultiplier;
        const orbitDuration = 2.5; // Seconds for one full orbit

        // Check if we should spawn new crosses
        if (!weapon.sacredCrossActive) {
            // Spawn crosses
            weapon.sacredCrossActive = true;
            weapon.sacredCrossTimer = orbitDuration; // Active for one orbit

            for (let i = 0; i < crossCount; i++) {
                const baseAngle = (Math.PI * 2 / crossCount) * i;
                const orbitSpeed = 2.0; // Radians per second

                const cross = this.projectilePool.get();
                cross.active = true;
                cross.init(
                    this.player.x + Math.cos(baseAngle) * effectiveRange,
                    this.player.y + Math.sin(baseAngle) * effectiveRange,
                    0, 0,
                    damage,
                    'player',
                    {
                        speed: 0,
                        radius: 10,
                        color: '#fbbf24',
                        pierce: 999,
                        lifetime: orbitDuration,
                        isSacredCross: true,
                        weaponType: 'sacred_cross',
                        orbitAngle: baseAngle,
                        orbitSpeed: orbitSpeed * (i % 2 === 0 ? 1 : -1), // Alternate CW/CCW rotation
                        orbitRadius: effectiveRange,
                        hitClearTimer: 0
                    }
                );
                this.projectiles.push(cross);
            }

            // Visual effect - holy particles
            for (let i = 0; i < crossCount * 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * effectiveRange;
                this.particles.emit(
                    this.player.x + Math.cos(angle) * dist,
                    this.player.y + Math.sin(angle) * dist,
                    { color: '#fbbf24', size: 4, life: 0.5, type: 'square' }
                );
            }
        }
    }

    // OPTIMIZATION: Cache array length for iteration
    updateSacredCrossWeapons(dt) {
        // Update cooldown timers for all sacred cross weapons
        const len = this.player.weapons.length;
        for (let i = 0; i < len; i++) {
            const weapon = this.player.weapons[i];
            if (weapon.id === 'sacredCross') {
                if (weapon.sacredCrossActive) {
                    weapon.sacredCrossTimer -= dt;
                    if (weapon.sacredCrossTimer <= 0) {
                        weapon.sacredCrossActive = false;
                        // Cooldown before next spawn = weapon base cooldown
                        weapon.sacredCrossTimer = -weapon.baseCooldown;
                    }
                } else {
                    weapon.sacredCrossTimer += dt;
                    if (weapon.sacredCrossTimer >= 0) {
                        // Ready to spawn again - will be handled by fireSacredCross
                    }
                }
            }
        }
    }

    firePoisonDagger(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        const target = this.findNearestEnemy(range);
        
        if (!target && count > 0) {
            // If no target, fire in player facing direction
            let facing = { ...this.player.facing };
            if (facing.x === 0 && facing.y === 0) {
                facing.x = 1;
            }
            
            for (let i = 0; i < count; i++) {
                const spreadAngle = (i - (count - 1) / 2) * 0.12;
                const cos = Math.cos(spreadAngle);
                const sin = Math.sin(spreadAngle);
                
                const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
                const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;
                
                const proj = this.projectilePool.get();
                proj.active = true;
                proj.init(
                    this.player.x, this.player.y,
                    vx, vy,
                    damage,
                    'player',
                    {
                        speed: weapon.projectileSpeed,
                        radius: 5,
                        color: '#4ade80',
                        pierce: 1,
                        lifetime: 1.5,
                        isPoisonDagger: true,
                        weaponType: 'poison_dagger'
                    }
                );
                this.projectiles.push(proj);
            }
            return;
        }

        for (let i = 0; i < count; i++) {
            const dx = target.x - this.player.x;
            const dy = target.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const vx = (dx / dist) * weapon.projectileSpeed;
            const vy = (dy / dist) * weapon.projectileSpeed;

            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 5,
                    color: '#4ade80',
                    pierce: 1,
                    lifetime: 1.5,
                    isPoisonDagger: true,
                    weaponType: 'poison_dagger'
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireSpinBlade(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        let facing = { ...this.player.facing };
        
        // Default to right if no direction
        if (facing.x === 0 && facing.y === 0) {
            facing.x = 1;
        }
        
        for (let i = 0; i < count; i++) {
            const spreadAngle = (i - (count - 1) / 2) * 0.15;
            const cos = Math.cos(spreadAngle);
            const sin = Math.sin(spreadAngle);
            
            const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
            const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;
            
            const blade = this.projectilePool.get();
            blade.active = true;
            blade.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 6,
                    color: '#e5e5e5',
                    pierce: weapon.pierce,
                    lifetime: 1.2,
                    isSpinBlade: true,
                    weaponType: 'spin_blade',
                    returnTime: 0.6,
                    returnSpeed: weapon.projectileSpeed * 1.5
                }
            );
            this.projectiles.push(blade);
        }
    }

    fireSoulOrb(weapon, damage, range) {
        const count = Math.min(weapon.projectileCount, 3); // Max 3 orbs

        for (let i = 0; i < count; i++) {
            const baseAngle = (Math.PI * 2 / count) * i;
            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                0, 0,
                damage,
                'player',
                {
                    speed: 0,
                    radius: 10,
                    color: '#9370db',
                    pierce: 999,
                    lifetime: weapon.orbLifetime || 4, // Orbs last 4 seconds
                    weaponType: 'soul_orb',
                    isSoulOrb: true,
                    orbitAngle: baseAngle,
                    orbitSpeed: 3.0, // Faster orbit
                    orbitRadius: range,
                    orbitCenterX: this.player.x,
                    orbitCenterY: this.player.y,
                    explosionDamage: weapon.explosionDamage || 1.5,
                    hasExploded: false
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireBoneSpear(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        let facing = { ...this.player.facing };

        if (facing.x === 0 && facing.y === 0) {
            facing.x = 1;
        }

        for (let i = 0; i < count; i++) {
            const spreadAngle = (i - (count - 1) / 2) * 0.1;
            const cos = Math.cos(spreadAngle);
            const sin = Math.sin(spreadAngle);

            const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
            const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;

            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 7,
                    color: '#d4c4a8',
                    pierce: weapon.pierce || 999,
                    lifetime: 3,
                    weaponType: 'bone_spear',
                    isBoneSpear: true
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireBloodMoonChakram(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        let facing = { ...this.player.facing };

        if (facing.x === 0 && facing.y === 0) {
            facing.x = 1;
        }

        for (let i = 0; i < count; i++) {
            const spreadAngle = (i - (count - 1) / 2) * 0.15;
            const cos = Math.cos(spreadAngle);
            const sin = Math.sin(spreadAngle);

            const vx = (facing.x * cos - facing.y * sin) * weapon.projectileSpeed;
            const vy = (facing.x * sin + facing.y * cos) * weapon.projectileSpeed;

            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 9,
                    color: '#ff6b6b',
                    pierce: weapon.pierce || 1,
                    lifetime: 1.5,
                    weaponType: 'blood_moon_chakram',
                    isBloodMoonChakram: true,
                    returnTime: 0.75,
                    returnSpeed: weapon.projectileSpeed * 1.3
                }
            );
            this.projectiles.push(proj);
        }
    }

    fireVampireDagger(weapon, damage, range) {
        const count = weapon.projectileCount + this.player.projectileBonus;
        const target = this.findNearestEnemy(range);

        for (let i = 0; i < count; i++) {
            let vx, vy;

            if (target) {
                const dx = target.x - this.player.x;
                const dy = target.y - this.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                vx = (dx / dist) * weapon.projectileSpeed;
                vy = (dy / dist) * weapon.projectileSpeed;
            } else {
                let facing = { ...this.player.facing };
                if (facing.x === 0 && facing.y === 0) facing.x = 1;
                vx = facing.x * weapon.projectileSpeed;
                vy = facing.y * weapon.projectileSpeed;
            }

            const proj = this.projectilePool.get();
            proj.active = true;
            proj.init(
                this.player.x, this.player.y,
                vx, vy,
                damage,
                'player',
                {
                    speed: weapon.projectileSpeed,
                    radius: 6,
                    color: '#8b0000',
                    pierce: 0,
                    lifetime: 2,
                    weaponType: 'vampire_dagger',
                    isVampireDagger: true,
                    lifestealHeal: weapon.lifestealHeal || 1 // Fixed +1 HP heal
                }
            );
            this.projectiles.push(proj);
        }
    }

    // OPTIMIZATION: Cache array length for iteration
    findNearestEnemy(range) {
        let nearest = null;
        let minDist = range * range;

        const len = this.enemies.length;
        for (let i = 0; i < len; i++) {
            const enemy = this.enemies[i];
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = dx * dx + dy * dy;

            if (dist < minDist) {
                minDist = dist;
                nearest = enemy;
            }
        }

        return nearest;
    }
    
    // OPTIMIZATION: Use squared distance and cache array lengths
    // OPTIMIZATION: Only rebuild spatial hash when enemies have moved
    updateEnemies(dt) {
        // OPTIMIZATION: Only rebuild spatial hash if enemies moved
        if (this.spatialHash.checkDirty(this.enemies)) {
            this.spatialHash.clear();
            const enemyLen = this.enemies.length;
            for (let i = 0; i < enemyLen; i++) {
                this.spatialHash.insert(this.enemies[i]);
            }
            this.spatialHash.storePositions(this.enemies);
        }

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            const dist = enemy.update(dt, this.player);

            // OPTIMIZATION: Use squared distance for collision check
            const combinedRadius = this.player.radius + enemy.radius;
            const combinedRadiusSq = combinedRadius * combinedRadius;
            const distSq = dist * dist;
            if (distSq < combinedRadiusSq && enemy.attackCooldown <= 0) {
                const dead = this.player.takeDamage(enemy.damage);
                enemy.attackCooldown = enemy.attackSpeed;

                if (dead) {
                    this.gameOver();
                    return;
                }
            }

            // Ranged enemy attack
            if (enemy.isRanged && enemy.attackCooldown <= 0) {
                // OPTIMIZATION: Use squared distance for range check
                const attackRangeSq = enemy.attackRange * enemy.attackRange;
                const distSqToPlayer = dist * dist;
                if (distSqToPlayer < attackRangeSq) {
                    // Fire projectile at player
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    const proj = this.projectilePool.get();
                    proj.active = true;
                    proj.init(
                        enemy.x, enemy.y,
                        (len > 0 ? (dx / len) * 200 : 200),
                        (len > 0 ? (dy / len) * 200 : 0),
                        enemy.damage,
                        'enemy',
                        { speed: 200, radius: 6, color: '#8b5cf6', lifetime: 5 }
                    );
                    this.projectiles.push(proj);

                    enemy.attackCooldown = enemy.attackSpeed;
                }
            }
        }
    }
    
    updateProjectiles(dt) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            if (!proj.active) {
                this.projectiles.splice(i, 1);
                continue;
            }

            const alive = proj.update(dt, this.player, this.enemies, this);

            if (!alive) {
                if (proj.isExplosive) {
                    this.createExplosion(proj.x, proj.y, proj.explosionRadius, proj.damage);
                }
                this.projectiles.splice(i, 1);
                this.projectilePool.release(proj);
                continue;
            }
            
            // Check bounds
            if (proj.x < 0 || proj.x > CONFIG.MAP_BOUNDS.width ||
                proj.y < 0 || proj.y > CONFIG.MAP_BOUNDS.height) {
                this.projectiles.splice(i, 1);
                this.projectilePool.release(proj);
                continue;
            }
            
            // Check collisions
            if (proj.owner === 'player') {
                // OPTIMIZATION: Create a copy of enemies array to avoid modification during iteration
                const enemiesToProcess = [...this.enemies];
                const enemiesToKill = [];
                
                const enemyLen = enemiesToProcess.length;
                for (let j = 0; j < enemyLen; j++) {
                    const enemy = enemiesToProcess[j];
                    if (proj.hitEnemies.has(enemy)) continue;

                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    // OPTIMIZATION: Use squared distance for collision check
                    const distSq = dx * dx + dy * dy;
                    const combinedRadius = enemy.radius + proj.radius;
                    const combinedRadiusSq = combinedRadius * combinedRadius;

                    if (distSq < combinedRadiusSq) {
                        let damage = proj.damage;
                        let isCrit = false;

                        if (proj.critChance && Math.random() < proj.critChance) {
                            damage *= 2;
                            isCrit = true;
                        }

                        const knockbackX = proj.vx * 0.05;
                        const knockbackY = proj.vy * 0.05;

                        const dead = enemy.takeDamage(damage, knockbackX, knockbackY);
                        this.damageNumbers.add(enemy.x, enemy.y - 20, damage, isCrit);

                        proj.hitEnemies.add(enemy);

                        // Apply Ice Shard slow effect
                        if (proj.isIceShard) {
                            enemy.applySlow(0.5, 1.5);
                        }

                        // Apply Poison Dagger poison effect
                        if (proj.isPoisonDagger) {
                            enemy.applyPoison(5.0);
                        }

                        // Apply Vampire Dagger lifesteal (fixed +1 HP)
                        if (proj.isVampireDagger && proj.lifestealHeal) {
                            const healAmount = proj.lifestealHeal; // Fixed +1 HP
                            this.player.heal(healAmount);
                            // Show heal effect
                            this.showPickupEffect(this.player.x, this.player.y - 20, `+${healAmount}`, 'health');
                        }

                        if (dead) {
                            enemiesToKill.push(enemy);
                        }

                        if (proj.isExplosive) {
                            // Don't remove projectile, it will explode on lifetime end
                        } else {
                            proj.pierce--;
                            if (proj.pierce <= 0) {
                                this.projectiles.splice(i, 1);
                                this.projectilePool.release(proj);
                                break;
                            }
                        }

                        if (!proj.isExplosive && proj.pierce <= 0) break;
                    }
                }
                
                // Kill enemies after processing all collisions
                for (let k = 0; k < enemiesToKill.length; k++) {
                    this.killEnemy(enemiesToKill[k]);
                }
                
                // Check if projectile was already removed
                if (i >= this.projectiles.length || !this.projectiles[i]) continue;
            } else {
                // Enemy projectile hitting player
                const dx = this.player.x - proj.x;
                const dy = this.player.y - proj.y;
                // OPTIMIZATION: Use squared distance for collision check
                const distSq = dx * dx + dy * dy;
                const combinedRadius = this.player.radius + proj.radius;
                const combinedRadiusSq = combinedRadius * combinedRadius;

                if (distSq < combinedRadiusSq) {
                    const dead = this.player.takeDamage(proj.damage);
                    this.projectiles.splice(i, 1);
                    this.projectilePool.release(proj);

                    if (dead) {
                        this.gameOver();
                        return;
                    }
                }
            }
        }
    }

    updateLightningBolts(dt) {
        // Update and remove expired lightning bolts
        for (let i = this.lightningBolts.length - 1; i >= 0; i--) {
            const bolt = this.lightningBolts[i];
            bolt.life -= dt;
            if (bolt.life <= 0) {
                this.lightningBolts.splice(i, 1);
            }
        }
    }

    // OPTIMIZATION: Use squared distance for explosion radius check
    createExplosion(x, y, radius, damage) {
        // OPTIMIZATION: Pre-calculate squared radius
        const radiusSq = radius * radius;
        
        // Create a copy to avoid modification during iteration
        const enemiesToProcess = [...this.enemies];
        const enemiesToKill = [];
        
        const enemyLen = enemiesToProcess.length;
        for (let i = 0; i < enemyLen; i++) {
            const enemy = enemiesToProcess[i];
            const dx = enemy.x - x;
            const dy = enemy.y - y;
            // OPTIMIZATION: Use squared distance
            const distSq = dx * dx + dy * dy;
            const combinedRadius = radius + enemy.radius;
            const combinedRadiusSq = combinedRadius * combinedRadius;

            if (distSq < combinedRadiusSq) {
                const dead = enemy.takeDamage(damage, dx * 0.1, dy * 0.1);
                this.damageNumbers.add(enemy.x, enemy.y - 20, damage);

                if (dead) {
                    enemiesToKill.push(enemy);
                }
            }
        }
        
        // Kill enemies after processing all damage
        for (let i = 0; i < enemiesToKill.length; i++) {
            this.killEnemy(enemiesToKill[i]);
        }

        // Visual
        this.particles.emitExplosion(x, y, '#ff6b35');
    }

    // OPTIMIZATION: Use squared distance and cache array lengths
    updateGroundEffects(dt) {
        for (let i = this.groundEffects.length - 1; i >= 0; i--) {
            const effect = this.groundEffects[i];
            const alive = effect.update(dt);

            if (!alive) {
                this.groundEffects.splice(i, 1);
                continue;
            }

            // Damage enemies in pool
            if (effect.tickCooldown <= 0) {
                effect.tickCooldown = effect.tickRate;

                // OPTIMIZATION: Cache array length and create a copy to avoid modification during iteration
                const enemiesToProcess = [...this.enemies];
                const enemiesToKill = [];
                
                const enemyLen = enemiesToProcess.length;
                for (let j = 0; j < enemyLen; j++) {
                    const enemy = enemiesToProcess[j];
                    if (effect.hitEnemies.has(enemy)) continue;

                    const dx = enemy.x - effect.x;
                    const dy = enemy.y - effect.y;
                    // OPTIMIZATION: Use squared distance
                    const distSq = dx * dx + dy * dy;
                    const combinedRadius = effect.radius + enemy.radius;
                    const combinedRadiusSq = combinedRadius * combinedRadius;

                    if (distSq < combinedRadiusSq) {
                        const dead = enemy.takeDamage(effect.damage, 0, 0);
                        this.damageNumbers.add(enemy.x, enemy.y - 20, effect.damage);

                        if (dead) {
                            enemiesToKill.push(enemy);
                        }
                    }
                }
                
                // Kill enemies after processing all damage
                for (let k = 0; k < enemiesToKill.length; k++) {
                    this.killEnemy(enemiesToKill[k]);
                }
            }
        }
    }
    
    updateXpGems(dt) {
        for (let i = this.xpGems.length - 1; i >= 0; i--) {
            const gem = this.xpGems[i];
            const collected = gem.update(dt, this.player);

            if (collected === true) {
                // Collected by player
                const leveledUp = this.player.addXp(gem.value);
                this.xpGems.splice(i, 1);

                // Only trigger level up if game is in playing state
                if (leveledUp && this.state === 'playing') {
                    this.triggerLevelUp();
                }
            } else if (collected === false && gem.lifetime <= 0) {
                // Expired - remove without collecting
                this.xpGems.splice(i, 1);
            }
        }
    }

    updateHealthPacks(dt) {
        for (let i = this.healthPacks.length - 1; i >= 0; i--) {
            const pack = this.healthPacks[i];
            const collected = pack.update(dt, this.player);

            if (collected) {
                // Heal player
                const healAmount = this.player.maxHp * pack.healPercent;
                this.player.heal(healAmount);

                // Show pickup effect
                this.showPickupEffect(pack.x, pack.y, `+${Math.round(healAmount)} HP`, 'health');

                this.healthPacks.splice(i, 1);
            }
        }
    }

    showPickupEffect(x, y, text, type) {
        // Create a floating text effect using the damage number system
        this.damageNumbers.numbers.push({
            x, y,
            damage: text,
            life: 0.8,
            isCrit: false,
            vy: -40,
            isHeal: true,
            healType: type
        });
    }

    killEnemy(enemy) {
        const index = this.enemies.indexOf(enemy);
        if (index !== -1) {
            this.enemies.splice(index, 1);
        }

        this.kills++;
        this.saveData.stats.totalKills++;

        // Calculate XP value with Treasure Wave bonus
        let xpValue = enemy.xpValue;
        if (this.activeEvents.treasureWave) {
            xpValue = Math.floor(xpValue * (1 + CONFIG.TREASURE_WAVE_XP_BONUS));
        }

        // Drop XP
        const gem = new XpGem(enemy.x, enemy.y, xpValue);
        this.xpGems.push(gem);

        // Spawn health pack every 100 kills
        if (this.kills % 100 === 0) {
            this.spawnHealthPack();
        }

        // Blood particles
        this.particles.emitBlood(enemy.x, enemy.y);
    }

    spawnHealthPack() {
        // Spawn at random position within map bounds
        const padding = 100;
        const x = padding + Math.random() * (CONFIG.MAP_BOUNDS.width - padding * 2);
        const y = padding + Math.random() * (CONFIG.MAP_BOUNDS.height - padding * 2);
        const healthPack = new HealthPack(x, y, 0.2); // Heals 20% HP
        this.healthPacks.push(healthPack);
    }
    
    triggerLevelUp() {
        this.state = 'levelup';
        this.pendingLevel = this.player.level;
        this.showLevelUpScreen();
    }
    
    showLevelUpScreen() {
        const screen = document.getElementById('levelUpScreen');
        const container = document.getElementById('upgradeCards');
        container.innerHTML = '';
        
        const options = this.generateUpgradeOptions();
        
        for (const option of options) {
            const card = this.createUpgradeCard(option);
            container.appendChild(card);
        }
        
        screen.style.display = 'block';
    }
    
    generateUpgradeOptions() {
        const options = [];
        const pool = [];
        
        // Add weapon upgrades
        for (const weapon of this.player.weapons) {
            if (weapon.level < weapon.maxLevel) {
                pool.push({
                    type: 'weaponUpgrade',
                    weapon: weapon,
                    weaponId: weapon.id,
                    rarity: this.getRarity()
                });
            }
        }
        
        // Add new weapon option (only if less than 6 weapons)
        if (this.player.weapons.length < 6) {
            for (const weaponId of Object.keys(WEAPONS)) {
                if (!this.player.weapons.find(w => w.id === weaponId)) {
                    pool.push({
                        type: 'newWeapon',
                        weaponId: weaponId,
                        rarity: 'rare'
                    });
                }
            }
        }
        
        // Add passive upgrades
        for (const passiveId of Object.keys(PASSIVES)) {
            const current = this.player.passives[passiveId] || 0;
            if (current < PASSIVES[passiveId].maxLevel) {
                pool.push({
                    type: 'passive',
                    passiveId: passiveId,
                    rarity: this.getRarity()
                });
            }
        }
        
        // Shuffle and select 3 unique options
        for (let i = pool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        
        const selected = [];
        const seen = new Set();
        
        for (const option of pool) {
            if (selected.length >= 3) break;
            
            let key = option.type;
            if (option.type === 'weaponUpgrade') key += option.weaponId;
            if (option.type === 'newWeapon') key += option.weaponId;
            if (option.type === 'passive') key += option.passiveId;
            
            if (!seen.has(key)) {
                seen.add(key);
                selected.push(option);
            }
        }
        
        // Ensure we have at least 3 options
        while (selected.length < 3 && pool.length > 0) {
            const random = pool[Math.floor(Math.random() * pool.length)];
            selected.push(random);
        }
        
        return selected;
    }
    
    getRarity() {
        const rand = Math.random();
        if (rand < 0.03) return 'legendary';
        if (rand < 0.15) return 'epic';
        if (rand < 0.5) return 'rare';
        return 'common';
    }
    
    createUpgradeCard(option) {
        const card = document.createElement('div');
        card.className = `upgrade-card ${option.rarity}`;
        
        let icon, name, description;
        
        if (option.type === 'weaponUpgrade') {
            const weapon = option.weapon;
            const nextLevel = weapon.level + 1;
            const upgrade = weapon.upgrades.find(u => u.level === nextLevel);
            
            icon = weapon.icon;
            name = `${weapon.name} Lv.${nextLevel}`;
            description = this.getUpgradeDescription(weapon, upgrade);
        } else if (option.type === 'newWeapon') {
            const weapon = WEAPONS[option.weaponId];
            icon = weapon.icon;
            name = weapon.name;
            description = weapon.description;
        } else if (option.type === 'passive') {
            const passive = PASSIVES[option.passiveId];
            const current = this.player.passives[option.passiveId] || 0;
            icon = passive.icon;
            name = `${passive.name} Lv.${current + 1}`;
            description = passive.description;
        }
        
        card.innerHTML = `
            <div class="upgrade-icon">${icon}</div>
            <div class="upgrade-name">${name}</div>
            <div class="upgrade-description">${description}</div>
            <span class="upgrade-rarity">${option.rarity}</span>
        `;
        
        card.onclick = () => this.selectUpgrade(option);
        
        return card;
    }
    
    getUpgradeDescription(weapon, upgrade) {
        if (!upgrade) return 'Max level reached';

        const parts = [];
        if (upgrade.damage) parts.push(`+${upgrade.damage} Damage`);
        if (upgrade.range) parts.push(`+${upgrade.range} Range`);

        // Special handling for Sacred Cross - show cross count increase
        if (upgrade.projectileCount) {
            if (weapon.id === 'sacredCross') {
                // Sacred Cross: +1 cross per level up to 6
                const nextCrossCount = Math.min(6, weapon.level + 1);
                parts.push(`${nextCrossCount} crosses total`);
            } else {
                parts.push(`+1 Projectile`);
            }
        }

        if (upgrade.pierce) parts.push(`+1 Pierce`);
        if (upgrade.tickRate) parts.push(`Faster Tick Rate`);
        if (upgrade.explosionRadius) parts.push(`+${upgrade.explosionRadius} Explosion`);
        if (upgrade.chainCount) parts.push(`+${upgrade.chainCount} Chains`);
        if (upgrade.chainRange) parts.push(`+${upgrade.chainRange} Chain Range`);
        if (upgrade.poolDuration) parts.push(`+${upgrade.poolDuration}s Duration`);
        if (upgrade.poolRadius) parts.push(`+${upgrade.poolRadius} Pool Size`);
        if (upgrade.critChance) parts.push(`+${(upgrade.critChance * 100).toFixed(0)}% Crit`);

        return parts.join(', ');
    }
    
    selectUpgrade(option) {
        if (option.type === 'weaponUpgrade') {
            const weapon = option.weapon;
            const nextLevel = weapon.level + 1;
            const upgrade = weapon.upgrades.find(u => u.level === nextLevel);

            if (upgrade) {
                weapon.level = nextLevel;
                if (upgrade.damage) weapon.damage += upgrade.damage;
                if (upgrade.range) weapon.range += upgrade.range;
                // Sacred Cross handles projectile count via weapon.level in fireSacredCross, not via projectileCount property
                if (upgrade.projectileCount && weapon.id !== 'sacredCross') {
                    weapon.projectileCount += upgrade.projectileCount;
                }
                if (upgrade.pierce) weapon.pierce += upgrade.pierce;
                if (upgrade.tickRate) weapon.tickRate += upgrade.tickRate;
                if (upgrade.explosionRadius) weapon.explosionRadius += upgrade.explosionRadius;
                if (upgrade.chainCount) weapon.chainCount += upgrade.chainCount;
                if (upgrade.chainRange) weapon.chainRange += upgrade.chainRange;
                if (upgrade.poolDuration) weapon.poolDuration += upgrade.poolDuration;
                if (upgrade.poolRadius) weapon.poolRadius += upgrade.poolRadius;
                if (upgrade.critChance) weapon.critChance += upgrade.critChance;
            }
        } else if (option.type === 'newWeapon') {
            const weapon = this.createWeapon(option.weaponId);
            this.player.weapons.push(weapon);
            
            if (!this.saveData.unlockedWeapons.includes(option.weaponId)) {
                this.saveData.unlockedWeapons.push(option.weaponId);
                this.saveGame();
            }
        } else if (option.type === 'passive') {
            const passiveId = option.passiveId;
            const passive = PASSIVES[passiveId];
            const current = this.player.passives[passiveId] || 0;
            
            if (current < passive.maxLevel) {
                this.player.passives[passiveId] = current + 1;
                const value = passive.values[current];
                
                switch (passive.stat) {
                    case 'movementSpeed':
                        this.player.movementBonus += value;
                        break;
                    case 'attackSpeed':
                        this.player.attackSpeedMultiplier += value;
                        break;
                    case 'damage':
                        this.player.damageMultiplier += value;
                        break;
                    case 'maxHealth':
                        this.player.maxHp += value;
                        this.player.heal(Math.floor(value * 0.3));
                        break;
                    case 'area':
                        this.player.areaMultiplier += value;
                        break;
                    case 'cooldownReduction':
                        this.player.cooldownReduction += value;
                        break;
                    case 'projectileCount':
                        this.player.projectileBonus += value;
                        break;
                    case 'pickupRange':
                        this.player.passives.goldMagnet = (this.player.passives.goldMagnet || 0) + value;
                        break;
                    case 'regeneration':
                        this.player.regeneration += value;
                        break;
                }
            }
        }

        document.getElementById('levelUpScreen').style.display = 'none';
        this.state = 'playing';
        this.lastTime = performance.now();
        
        // Reset joystick and input
        if (this.joystick) {
            this.joystick.setActive(false);
        }
        this.input.resetJoystick();
        
        this.updateWeaponBar();
        requestAnimationFrame(() => this.gameLoop());
    }

    gameOver() {
        this.state = 'gameover';
        this.saveData.stats.totalPlayTime += Math.floor(this.gameTime);
        this.saveData.stats.highestWave = Math.max(this.saveData.stats.highestWave, this.wave);
        this.saveGame();

        // Reset joystick and input
        if (this.joystick) {
            this.joystick.setActive(false);
        }
        this.input.resetJoystick();
        this.updatePauseButtonIcon(false);

        const screen = document.getElementById('gameOverScreen');
        const title = document.getElementById('gameOverTitle');
        const stats = document.getElementById('endStats');

        title.textContent = 'GAME OVER';
        title.className = 'game-over-title';
        stats.innerHTML = `
            <div class="stat-item">
                <div class="stat-item-label">Time Survived</div>
                <div class="stat-item-value">${this.formatTime(this.gameTime)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Level Reached</div>
                <div class="stat-item-value">${this.player.level}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Enemies Killed</div>
                <div class="stat-item-value">${this.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Wave Reached</div>
                <div class="stat-item-value">${this.wave}</div>
            </div>
        `;

        screen.style.display = 'block';
    }

    victory() {
        this.state = 'victory';
        this.saveData.stats.totalPlayTime += Math.floor(this.gameTime);
        this.saveData.stats.runsCompleted++;
        this.saveData.stats.highestWave = Math.max(this.saveData.stats.highestWave, this.wave);
        this.saveGame();

        // Reset joystick and input
        if (this.joystick) {
            this.joystick.setActive(false);
        }
        this.input.resetJoystick();
        this.updatePauseButtonIcon(false);

        const screen = document.getElementById('gameOverScreen');
        const title = document.getElementById('gameOverTitle');
        const stats = document.getElementById('endStats');

        title.textContent = 'VICTORY!';
        title.className = 'victory-title';
        stats.innerHTML = `
            <div class="stat-item">
                <div class="stat-item-label">Time Survived</div>
                <div class="stat-item-value">${this.formatTime(this.gameTime)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Final Level</div>
                <div class="stat-item-value">${this.player.level}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Total Kills</div>
                <div class="stat-item-value">${this.kills}</div>
            </div>
            <div class="stat-item">
                <div class="stat-item-label">Wave Completed</div>
                <div class="stat-item-value">${this.wave}</div>
            </div>
        `;
        
        screen.style.display = 'block';
    }
    
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    updateUI() {
        document.getElementById('levelValue').textContent = this.player.level;

        const xpPercent = (this.player.xp / this.player.xpToNext) * 100;
        document.getElementById('xpBar').style.width = `${xpPercent}%`;

        document.getElementById('timer').textContent = this.formatTime(this.gameTime);
        
        const hpPercent = Math.max(0, Math.min(100, (this.player.hp / this.player.maxHp) * 100));
        document.getElementById('healthBar').style.width = `${hpPercent}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)} / ${this.player.maxHp}`;
        
        document.getElementById('killsValue').textContent = this.kills;
        document.getElementById('waveValue').textContent = this.wave;
    }
    
    updateWeaponBar() {
        const bar = document.getElementById('weaponBar');
        bar.innerHTML = '';
        
        for (let i = 0; i < 6; i++) {
            const slot = document.createElement('div');
            slot.className = 'weapon-slot';
            
            if (i < this.player.weapons.length) {
                const weapon = this.player.weapons[i];
                slot.classList.add('has-weapon');
                slot.innerHTML = `
                    ${weapon.icon}
                    <span class="weapon-level">${weapon.level}</span>
                    <div class="cooldown-overlay" id="cd-${i}" style="height: 0%"></div>
                `;
            }
            
            bar.appendChild(slot);
        }
    }

    updateWeaponCooldowns() {
        // Disabled: Visual cooldown overlay removed to prevent distracting flashing
        // Cooldown system still works, just no visual overlay
        return;
    }

    render() {
        const ctx = this.ctx;

        // Clear screen
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw background grid
        this.renderBackground();

        // Render game world
        ctx.save();
        ctx.translate(-this.camera.x, -this.camera.y);

        // Draw decorations (trees, rocks, ruins, etc.) - BELOW entities
        this.renderDecorations();

        // Draw ground effects
        this.renderGroundEffects();

        // Draw XP gems
        this.renderXpGems();

        // Draw health packs
        this.renderHealthPacks();

        // Draw enemies
        this.renderEnemies();

        // Draw player
        this.renderPlayer();

        // Draw projectiles
        this.renderProjectiles();

        // Draw lightning bolts
        this.renderLightningBolts();

        // Draw particles
        this.particles.render(ctx);

        ctx.restore();

        // Draw damage numbers (screen space)
        this.damageNumbers.render(ctx, this.camera.x, this.camera.y);

        // Draw wave notifications
        this.renderWaveNotifications();
        
        // Draw event notifications
        this.renderEventNotifications();
        
        // Draw Blood Moon overlay
        this.renderBloodMoonOverlay();

        // Update weapon cooldowns UI
        this.updateWeaponCooldowns();
    }
    
    renderBackground() {
        const ctx = this.ctx;
        const gridSize = 100;
        const startX = Math.floor(this.camera.x / gridSize) * gridSize;
        const startY = Math.floor(this.camera.y / gridSize) * gridSize;
        
        ctx.strokeStyle = '#252545';
        ctx.lineWidth = 1;
        
        for (let x = startX; x < this.camera.x + this.canvas.width + gridSize; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, this.camera.y);
            ctx.lineTo(x, this.camera.y + this.canvas.height);
            ctx.stroke();
        }
        
        for (let y = startY; y < this.camera.y + this.canvas.height + gridSize; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(this.camera.x, y);
            ctx.lineTo(this.camera.x + this.canvas.width, y);
            ctx.stroke();
        }
        
        // Draw map boundaries
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, CONFIG.MAP_BOUNDS.width, CONFIG.MAP_BOUNDS.height);
    }
    
    renderPlayer() {
        const ctx = this.ctx;
        const p = this.player;

        // Validate player position and radius to prevent gradient errors
        if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.radius) || p.radius <= 0) {
            return; // Skip rendering invalid player
        }

        // Blink when invincible using game timer for consistency
        if (p.invincible) {
            // Use game.gameTime for consistent 10Hz blink (not countdown timer)
            if (Math.floor(this.gameTime * 10) % 2 === 0) {
                return; // Skip rendering this frame
            }
        }

        // Calculate facing direction for sprite orientation
        let facingX = p.facing.x;
        let facingY = p.facing.y;
        if (facingX === 0 && facingY === 0) facingX = 1; // Default facing right

        const radius = p.radius;
        const centerX = p.x;
        const centerY = p.y;

        // Validate calculated values before rendering
        if (!isFinite(centerX) || !isFinite(centerY) || !isFinite(radius)) {
            return;
        }

        // Draw cape/cloth trailing behind (opposite of movement direction)
        const capeLength = radius * 0.8;
        const capeAngle = Math.atan2(-facingY, -facingX);
        const capeX = centerX + Math.cos(capeAngle) * radius * 0.5;
        const capeY = centerY + Math.sin(capeAngle) * radius * 0.5;

        // Validate cape position
        if (!isFinite(capeX) || !isFinite(capeY)) {
            return;
        }

        ctx.fillStyle = '#155e75'; // Dark teal cape
        ctx.beginPath();
        ctx.moveTo(capeX, capeY);
        ctx.lineTo(capeX + Math.cos(capeAngle - 0.5) * capeLength, capeY + Math.sin(capeAngle - 0.5) * capeLength);
        ctx.lineTo(capeX + Math.cos(capeAngle + 0.5) * capeLength, capeY + Math.sin(capeAngle + 0.5) * capeLength);
        ctx.closePath();
        ctx.fill();

        // Draw body with gradient - validate gradient parameters
        const innerRadius = 0;
        const outerRadius = radius;
        const gradientX = centerX - radius * 0.3;
        const gradientY = centerY - radius * 0.3;

        if (!isFinite(gradientX) || !isFinite(gradientY) || !isFinite(outerRadius) || outerRadius <= 0) {
            return;
        }

        const bodyGradient = ctx.createRadialGradient(
            gradientX, gradientY, innerRadius,
            centerX, centerY, outerRadius
        );
        bodyGradient.addColorStop(0, '#86efac'); // Light green highlight
        bodyGradient.addColorStop(0.5, '#4ade80'); // Main green
        bodyGradient.addColorStop(1, '#22c55e'); // Darker green edge

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw body outline
        ctx.strokeStyle = '#16a34a';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Draw eyes that face the movement direction
        const eyeOffsetX = facingX * radius * 0.25;
        const eyeOffsetY = facingY * radius * 0.25;
        const eyeSpacing = radius * 0.35;
        const eyeAngle = Math.atan2(facingY, facingX);
        const perpAngle = eyeAngle + Math.PI / 2;

        // Eye positions (perpendicular to facing direction)
        const leftEyeX = centerX + eyeOffsetX + Math.cos(perpAngle) * eyeSpacing;
        const leftEyeY = centerY + eyeOffsetY + Math.sin(perpAngle) * eyeSpacing;
        const rightEyeX = centerX + eyeOffsetX - Math.cos(perpAngle) * eyeSpacing;
        const rightEyeY = centerY + eyeOffsetY - Math.sin(perpAngle) * eyeSpacing;

        // White of eyes
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(leftEyeX, leftEyeY, radius * 0.28, 0, Math.PI * 2);
        ctx.arc(rightEyeX, rightEyeY, radius * 0.28, 0, Math.PI * 2);
        ctx.fill();

        // Black pupils (looking in facing direction)
        const pupilOffset = radius * 0.15;
        const pupilX = pupilOffset * facingX;
        const pupilY = pupilOffset * facingY;

        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(leftEyeX + pupilX, leftEyeY + pupilY, radius * 0.15, 0, Math.PI * 2);
        ctx.arc(rightEyeX + pupilX, rightEyeY + pupilY, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Draw magic aura range indicator if owned
        const aura = p.weapons.find(w => w.id === 'magicAura');
        if (aura) {
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(p.x, p.y, aura.range * p.areaMultiplier, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    // OPTIMIZATION: Use separate if statements for frustum culling (better branch prediction)
    renderEnemies() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.enemies.length;
        for (let i = 0; i < len; i++) {
            const enemy = this.enemies[i];

            // OPTIMIZATION: Separate if statements for better branch prediction
            if (enemy.x + enemy.radius < camLeft) continue;
            if (enemy.x - enemy.radius > camRight) continue;
            if (enemy.y + enemy.radius < camTop) continue;
            if (enemy.y - enemy.radius > camBottom) continue;

            switch (enemy.type) {
                case 'zombie':
                    this.renderZombie(enemy);
                    break;
                case 'ghoul':
                    this.renderGhoul(enemy);
                    break;
                case 'skeleton':
                    this.renderSkeleton(enemy);
                    break;
                case 'witch':
                    this.renderWitch(enemy);
                    break;
                case 'shadowStalker':
                    this.renderShadowStalker(enemy);
                    break;
                case 'demonImp':
                    this.renderDemonImp(enemy);
                    break;
                case 'cursedKnight':
                    this.renderCursedKnight(enemy);
                    break;
                case 'plagueBats':
                    this.renderPlagueBats(enemy);
                    break;
                case 'necromancer':
                    this.renderNecromancer(enemy);
                    break;
                case 'voidReaper':
                    this.renderVoidReaper(enemy);
                    break;
                // NEW MONSTERS
                case 'cryptWraith':
                    this.renderCryptWraith(enemy);
                    break;
                case 'berserkerMutant':
                    this.renderBerserkerMutant(enemy);
                    break;
                case 'darkPriest':
                    this.renderDarkPriest(enemy);
                    break;
                case 'crystalGolem':
                    this.renderCrystalGolem(enemy);
                    break;
                // BOSSES
                case 'lordOfBones':
                    this.renderLordOfBones(enemy);
                    break;
                case 'bloodQueen':
                    this.renderBloodQueen(enemy);
                    break;
                case 'voidLord':
                    this.renderVoidLord(enemy);
                    break;
            }

            // Draw health bar for damaged enemies
            if (enemy.hp < enemy.maxHp) {
                const barWidth = 30;
                const barHeight = 4;
                const hpPercent = Math.max(0, enemy.hp / enemy.maxHp);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 10, barWidth, barHeight);
                ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : hpPercent > 0.25 ? '#eab308' : '#ef4444';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 10, barWidth * hpPercent, barHeight);
            }
        }
    }

    renderZombie(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Body - irregular green shape
        ctx.fillStyle = '#4a7c4e';
        ctx.beginPath();
        // Slightly irregular circle for zombie
        for (let i = 0; i < Math.PI * 2; i += 0.3) {
            const r = radius * (0.9 + Math.sin(i * 3) * 0.1);
            const px = x + Math.cos(i) * r;
            const py = y + Math.sin(i) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Dark spots on body
        ctx.fillStyle = '#2d4a2f';
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y - radius * 0.2, radius * 0.2, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y + radius * 0.15, radius * 0.18, 0, Math.PI * 2);
        ctx.arc(x - radius * 0.15, y + radius * 0.3, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Dull yellow-green eyes
        ctx.fillStyle = '#8b9c6b';
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y - radius * 0.15, radius * 0.2, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y - radius * 0.15, radius * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Small black pupils
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#1a2a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderGhoul(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Body - brown/tan with sharp features
        const bodyGradient = ctx.createRadialGradient(
            x - radius * 0.2, y - radius * 0.2, 0,
            x, y, radius
        );
        bodyGradient.addColorStop(0, '#a07050');
        bodyGradient.addColorStop(1, '#6b4423');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();

        // Elongated, sharp shape
        ctx.ellipse(x, y, radius * 0.9, radius * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();

        // Sharp facial features - ridges
        ctx.fillStyle = '#4a2f1a';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.4, y - radius * 0.5);
        ctx.lineTo(x - radius * 0.2, y);
        ctx.lineTo(x - radius * 0.5, y + radius * 0.3);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + radius * 0.4, y - radius * 0.5);
        ctx.lineTo(x + radius * 0.2, y);
        ctx.lineTo(x + radius * 0.5, y + radius * 0.3);
        ctx.fill();

        // Glowing yellow eyes (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.2, radius * 0.18, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.2, radius * 0.18, 0, Math.PI * 2);
        ctx.fill();

        // Black slit pupils
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.25, y - radius * 0.2, radius * 0.06, radius * 0.15, 0, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.25, y - radius * 0.2, radius * 0.06, radius * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#3a2010';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderSkeleton(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Bone white body
        ctx.fillStyle = '#e8dcc5';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Rib cage lines
        ctx.strokeStyle = '#c4b5a0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Horizontal rib lines
        for (let i = -2; i <= 2; i++) {
            const ribY = y + i * (radius * 0.25);
            const ribWidth = radius * 0.7 * (1 - Math.abs(i) * 0.15);
            ctx.moveTo(x - ribWidth, ribY);
            ctx.lineTo(x + ribWidth, ribY);
        }
        // Spine line
        ctx.moveTo(x, y - radius * 0.5);
        ctx.lineTo(x, y + radius * 0.5);
        ctx.stroke();

        // Dark eye sockets
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.3, y - radius * 0.15, radius * 0.22, radius * 0.25, 0, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.3, y - radius * 0.15, radius * 0.22, radius * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glowing pupils in sockets (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Nose cavity
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(x, y + radius * 0.1);
        ctx.lineTo(x - radius * 0.1, y + radius * 0.25);
        ctx.lineTo(x + radius * 0.1, y + radius * 0.25);
        ctx.closePath();
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#a09080';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderWitch(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Purple robe/body
        const robeGradient = ctx.createRadialGradient(
            x, y + radius * 0.2, 0,
            x, y, radius * 1.2
        );
        robeGradient.addColorStop(0, '#8b5cf6');
        robeGradient.addColorStop(1, '#5b21b6');

        ctx.fillStyle = robeGradient;
        ctx.beginPath();
        // Robe shape - wider at bottom
        ctx.moveTo(x - radius * 0.8, y + radius * 0.9);
        ctx.lineTo(x - radius * 0.7, y - radius * 0.3);
        ctx.arc(x, y - radius * 0.5, radius * 0.6, Math.PI, 0);
        ctx.lineTo(x + radius * 0.8, y + radius * 0.9);
        ctx.closePath();
        ctx.fill();

        // Pointed hat
        ctx.fillStyle = '#4c1d95';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.7, y - radius * 0.3);
        ctx.lineTo(x, y - radius * 1.3); // Pointy top
        ctx.lineTo(x + radius * 0.7, y - radius * 0.3);
        ctx.closePath();
        ctx.fill();

        // Hat band
        ctx.fillStyle = '#7c3aed';
        ctx.fillRect(x - radius * 0.7, y - radius * 0.4, radius * 1.4, radius * 0.15);

        // Glowing yellow eyes (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ffff66';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.1, radius * 0.15, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.1, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Black pupils
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.1, radius * 0.06, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.1, radius * 0.06, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#3b0764';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderShadowStalker(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Dark gray/black body with semi-transparent effect
        ctx.fillStyle = 'rgba(45, 45, 45, 0.9)';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Glowing red eyes (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y - radius * 0.1, radius * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Black pupils
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y - radius * 0.1, radius * 0.08, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y - radius * 0.1, radius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderDemonImp(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Red-orange body
        const bodyGradient = ctx.createRadialGradient(
            x - radius * 0.2, y - radius * 0.2, 0,
            x, y, radius
        );
        bodyGradient.addColorStop(0, '#ff6b4a');
        bodyGradient.addColorStop(1, '#c44536');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        // Elongated imp shape
        ctx.ellipse(x, y, radius * 0.85, radius * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();

        // Small horns
        ctx.fillStyle = '#8b2a1a';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.4, y - radius * 0.8);
        ctx.lineTo(x - radius * 0.3, y - radius * 1.1);
        ctx.lineTo(x - radius * 0.2, y - radius * 0.8);
        ctx.moveTo(x + radius * 0.4, y - radius * 0.8);
        ctx.lineTo(x + radius * 0.3, y - radius * 1.1);
        ctx.lineTo(x + radius * 0.2, y - radius * 0.8);
        ctx.fill();

        // Yellow eyes (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.15, radius * 0.15, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.15, radius * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Black pupils
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.15, radius * 0.06, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.15, radius * 0.06, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#6b1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderCursedKnight(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Steel blue-gray armor
        const armorGradient = ctx.createRadialGradient(
            x - radius * 0.3, y - radius * 0.3, 0,
            x, y, radius
        );
        armorGradient.addColorStop(0, '#7a8b9c');
        armorGradient.addColorStop(0.5, '#5a6b7c');
        armorGradient.addColorStop(1, '#3a4b5c');

        ctx.fillStyle = armorGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Armor plates
        ctx.strokeStyle = '#2a3b4c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();

        // Vertical plate lines
        ctx.beginPath();
        ctx.moveTo(x, y - radius * 0.7);
        ctx.lineTo(x, y + radius * 0.7);
        ctx.moveTo(x - radius * 0.5, y - radius * 0.3);
        ctx.lineTo(x + radius * 0.5, y - radius * 0.3);
        ctx.stroke();

        // Glowing orange eyes (from helmet slits) - removed expensive shadowBlur for performance
        ctx.fillStyle = '#ff8833';
        ctx.fillRect(x - radius * 0.35, y - radius * 0.2, radius * 0.25, radius * 0.1);
        ctx.fillRect(x + radius * 0.1, y - radius * 0.2, radius * 0.25, radius * 0.1);

        // Dark outline
        ctx.strokeStyle = '#1a2b3c';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    renderPlagueBats(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Sickly green swarm of bats
        ctx.fillStyle = '#6b8c42';
        
        // Draw 3 small bat shapes
        const batPositions = [
            { dx: -0.4, dy: -0.3, size: 0.7 },
            { dx: 0.3, dy: -0.2, size: 0.8 },
            { dx: 0, dy: 0.2, size: 0.6 }
        ];

        for (const pos of batPositions) {
            const bx = x + pos.dx * radius;
            const by = y + pos.dy * radius;
            const bSize = radius * pos.size * 0.5;

            // Bat body
            ctx.beginPath();
            ctx.arc(bx, by, bSize, 0, Math.PI * 2);
            ctx.fill();

            // Bat wings
            ctx.beginPath();
            ctx.moveTo(bx - bSize, by);
            ctx.quadraticCurveTo(bx - bSize * 2, by - bSize, bx - bSize * 2.5, by);
            ctx.quadraticCurveTo(bx - bSize * 2, by + bSize, bx - bSize, by);
            ctx.moveTo(bx + bSize, by);
            ctx.quadraticCurveTo(bx + bSize * 2, by - bSize, bx + bSize * 2.5, by);
            ctx.quadraticCurveTo(bx + bSize * 2, by + bSize, bx + bSize, by);
            ctx.fill();
        }

        // Glowing green eyes for each bat (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#88aa44';
        for (const pos of batPositions) {
            const bx = x + pos.dx * radius;
            const by = y + pos.dy * radius;
            ctx.beginPath();
            ctx.arc(bx - pos.size * radius * 0.1, by - pos.size * radius * 0.1, radius * 0.08, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    renderNecromancer(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Dark purple hooded robe
        const robeGradient = ctx.createRadialGradient(
            x, y + radius * 0.3, 0,
            x, y, radius * 1.1
        );
        robeGradient.addColorStop(0, '#6a4d7c');
        robeGradient.addColorStop(1, '#2a1d3c');

        ctx.fillStyle = robeGradient;
        ctx.beginPath();
        // Robe shape
        ctx.moveTo(x - radius * 0.7, y + radius * 0.8);
        ctx.lineTo(x - radius * 0.6, y - radius * 0.4);
        ctx.arc(x, y - radius * 0.6, radius * 0.5, Math.PI, 0);
        ctx.lineTo(x + radius * 0.6, y + radius * 0.8);
        ctx.closePath();
        ctx.fill();

        // Hood shadow
        ctx.fillStyle = '#1a0f2c';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.5, radius * 0.45, 0, Math.PI * 2);
        ctx.fill();

        // Glowing staff (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#cc66ff';
        ctx.fillRect(x + radius * 0.4, y - radius * 0.8, radius * 0.15, radius * 1.8);

        // Glowing eyes from hood
        ctx.fillStyle = '#ff44ff';
        ctx.beginPath();
        ctx.arc(x - radius * 0.15, y - radius * 0.5, radius * 0.08, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.15, y - radius * 0.5, radius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Dark outline
        ctx.strokeStyle = '#2a1f3c';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    renderVoidReaper(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Deep purple-black body with particle trail effect
        const bodyGradient = ctx.createRadialGradient(
            x, y, 0,
            x, y, radius
        );
        bodyGradient.addColorStop(0, '#5a2f6a');
        bodyGradient.addColorStop(0.7, '#3d1f4a');
        bodyGradient.addColorStop(1, '#1a0f2a');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        // Imposing figure shape - larger at top
        ctx.moveTo(x - radius * 0.7, y + radius * 0.9);
        ctx.lineTo(x - radius * 0.6, y - radius * 0.5);
        ctx.arc(x, y - radius * 0.7, radius * 0.65, Math.PI, 0);
        ctx.lineTo(x + radius * 0.7, y + radius * 0.9);
        ctx.closePath();
        ctx.fill();

        // Dark hood
        ctx.fillStyle = '#0f051a';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.65, radius * 0.55, 0, Math.PI * 2);
        ctx.fill();

        // Glowing scythe (removed expensive shadowBlur for performance)
        ctx.strokeStyle = '#cc66ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + radius * 0.5, y);
        ctx.lineTo(x + radius * 1.2, y - radius * 0.8);
        ctx.quadraticCurveTo(x + radius * 1.5, y - radius * 1.0, x + radius * 1.3, y - radius * 0.6);
        ctx.stroke();

        // Menacing glowing eyes (removed expensive shadowBlur for performance)
        ctx.fillStyle = '#ff44ff';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.2, y - radius * 0.6, radius * 0.12, radius * 0.08, -0.2, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.2, y - radius * 0.6, radius * 0.12, radius * 0.08, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // OPTIMIZATION: Removed unnecessary ctx.shadowBlur = 0
        // Particle trail effect
        for (let i = 0; i < 5; i++) {
            const trailX = x + (Math.random() - 0.5) * radius * 1.5;
            const trailY = y + radius * 0.8 + Math.random() * radius * 0.5;
            ctx.fillStyle = `rgba(170, 68, 255, ${0.2 + Math.random() * 0.3})`;
            ctx.beginPath();
            ctx.arc(trailX, trailY, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Dark outline
        ctx.strokeStyle = '#1a0f2a';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    // ==================== BOSS RENDERING ====================
    renderLordOfBones(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Bone-colored body with glow
        const bodyGradient = ctx.createRadialGradient(x, y - radius * 0.3, 0, x, y, radius);
        bodyGradient.addColorStop(0, '#f5f5dc');
        bodyGradient.addColorStop(0.5, '#c4b494');
        bodyGradient.addColorStop(1, '#8b7d6b');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Skull face
        ctx.fillStyle = '#2d1a0a';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.25, y - radius * 0.15, radius * 0.2, radius * 0.25, 0, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.25, y - radius * 0.15, radius * 0.2, radius * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glowing orange eyes
        ctx.fillStyle = '#ff6b35';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.15, radius * 0.1, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.15, radius * 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Bone crown/spikes
        ctx.fillStyle = '#c4b494';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.5, y - radius * 0.8);
        ctx.lineTo(x - radius * 0.7, y - radius * 1.2);
        ctx.lineTo(x - radius * 0.3, y - radius * 0.9);
        ctx.lineTo(x, y - radius * 1.3);
        ctx.lineTo(x + radius * 0.3, y - radius * 0.9);
        ctx.lineTo(x + radius * 0.7, y - radius * 1.2);
        ctx.lineTo(x + radius * 0.5, y - radius * 0.8);
        ctx.closePath();
        ctx.fill();

        // Ribcage pattern
        ctx.strokeStyle = '#8b7d6b';
        ctx.lineWidth = 2;
        for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.arc(x, y + radius * 0.3, radius * 0.8 - i * radius * 0.15, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        // Boss health bar indicator
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.1, 0, Math.PI * 2);
        ctx.stroke();
    }

    renderBloodQueen(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Blood red dress/body
        const dressGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        dressGradient.addColorStop(0, '#cc0000');
        dressGradient.addColorStop(0.6, '#8b0000');
        dressGradient.addColorStop(1, '#4a0000');

        ctx.fillStyle = dressGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 0.9, radius * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pale face
        ctx.fillStyle = '#ffd4cc';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.5, radius * 0.4, 0, Math.PI * 2);
        ctx.fill();

        // Blood crown
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.35, y - radius * 0.7);
        ctx.lineTo(x - radius * 0.35, y - radius * 0.95);
        ctx.lineTo(x - radius * 0.2, y - radius * 0.75);
        ctx.lineTo(x, y - radius * 1.0);
        ctx.lineTo(x + radius * 0.2, y - radius * 0.75);
        ctx.lineTo(x + radius * 0.35, y - radius * 0.95);
        ctx.lineTo(x + radius * 0.35, y - radius * 0.7);
        ctx.closePath();
        ctx.fill();

        // Blood red eyes
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.15, y - radius * 0.5, radius * 0.12, radius * 0.08, 0, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.15, y - radius * 0.5, radius * 0.12, radius * 0.08, 0, 0, Math.PI * 2);
        ctx.fill();

        // Blood aura
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.15, 0, Math.PI * 2);
        ctx.stroke();
    }

    renderVoidLord(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Void aura
        const voidGradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 1.2);
        voidGradient.addColorStop(0, 'rgba(192, 132, 252, 0.3)');
        voidGradient.addColorStop(0.5, 'rgba(107, 44, 145, 0.5)');
        voidGradient.addColorStop(1, 'rgba(45, 26, 74, 0)');

        ctx.fillStyle = voidGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.2, 0, Math.PI * 2);
        ctx.fill();

        // Dark body
        const bodyGradient = ctx.createRadialGradient(x, y - radius * 0.2, 0, x, y, radius);
        bodyGradient.addColorStop(0, '#6b4c7a');
        bodyGradient.addColorStop(0.5, '#3d2a5a');
        bodyGradient.addColorStop(1, '#1a0f2e');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 0.95, radius * 1.05, 0, 0, Math.PI * 2);
        ctx.fill();

        // Void face mask
        ctx.fillStyle = '#0f051e';
        ctx.beginPath();
        ctx.ellipse(x, y - radius * 0.3, radius * 0.5, radius * 0.4, 0, Math.PI, 0);
        ctx.fill();

        // Glowing purple eyes
        ctx.fillStyle = '#c084fc';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.2, y - radius * 0.35, radius * 0.15, radius * 0.1, 0, 0, Math.PI * 2);
        ctx.ellipse(x + radius * 0.2, y - radius * 0.35, radius * 0.15, radius * 0.1, 0, 0, Math.PI * 2);
        ctx.fill();

        // Void crown/horns
        ctx.fillStyle = '#2d1a4a';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.4, y - radius * 0.7);
        ctx.lineTo(x - radius * 0.6, y - radius * 1.1);
        ctx.lineTo(x - radius * 0.25, y - radius * 0.8);
        ctx.lineTo(x, y - radius * 1.2);
        ctx.lineTo(x + radius * 0.25, y - radius * 0.8);
        ctx.lineTo(x + radius * 0.6, y - radius * 1.1);
        ctx.lineTo(x + radius * 0.4, y - radius * 0.7);
        ctx.closePath();
        ctx.fill();

        // Void stars inside body
        ctx.fillStyle = '#c084fc';
        for (let i = 0; i < 8; i++) {
            const starX = x + (Math.random() - 0.5) * radius * 1.2;
            const starY = y + (Math.random() - 0.5) * radius * 1.4;
            ctx.beginPath();
            ctx.arc(starX, starY, radius * 0.05, 0, Math.PI * 2);
            ctx.fill();
        }

        // Boss health bar indicator
        ctx.strokeStyle = '#c084fc';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.15, 0, Math.PI * 2);
        ctx.stroke();
    }

    // ==================== NEW MONSTER RENDERING ====================
    renderCryptWraith(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Ghostly translucent body
        ctx.fillStyle = 'rgba(125, 107, 143, 0.7)';
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 0.7, radius, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hood
        ctx.fillStyle = '#5a4d6a';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.3, radius * 0.5, Math.PI, 0);
        ctx.fill();

        // Glowing red eyes
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.25, radius * 0.12, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.2, y - radius * 0.25, radius * 0.12, 0, Math.PI * 2);
        ctx.fill();

        // Wispy edges
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#7d6b8f';
        ctx.beginPath();
        ctx.arc(x - radius * 0.4, y + radius * 0.5, radius * 0.25, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.4, y + radius * 0.5, radius * 0.25, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }

    renderBerserkerMutant(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Reddish body
        const bodyGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        bodyGradient.addColorStop(0, '#c48b8b');
        bodyGradient.addColorStop(1, '#8b3d3d');

        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Wild hair
        ctx.fillStyle = '#4a3728';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.6, radius * 0.5, Math.PI, 0);
        ctx.fill();

        // Angry eyebrows
        ctx.strokeStyle = '#2d1f15';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.3, y - radius * 0.4);
        ctx.lineTo(x - radius * 0.1, y - radius * 0.3);
        ctx.moveTo(x + radius * 0.3, y - radius * 0.4);
        ctx.lineTo(x + radius * 0.1, y - radius * 0.3);
        ctx.stroke();

        // Bloodshot eyes
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x - radius * 0.25, y - radius * 0.15, radius * 0.18, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.25, y - radius * 0.15, radius * 0.18, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.2, y - radius * 0.15, radius * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Rage veins
        ctx.strokeStyle = '#8b3d3d';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + radius * 0.3, y - radius * 0.5);
        ctx.quadraticCurveTo(x + radius * 0.4, y - radius * 0.4, x + radius * 0.35, y - radius * 0.3);
        ctx.stroke();
    }

    renderDarkPriest(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Dark purple robe
        const robeGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        robeGradient.addColorStop(0, '#4a3d5a');
        robeGradient.addColorStop(1, '#1a0f2e');

        ctx.fillStyle = robeGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 0.8, radius * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();

        // Deep hood
        ctx.fillStyle = '#2d1a4a';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.3, radius * 0.5, Math.PI, 0);
        ctx.fill();

        // Glowing purple eyes
        ctx.fillStyle = '#c084fc';
        ctx.beginPath();
        ctx.arc(x - radius * 0.2, y - radius * 0.25, radius * 0.12, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.2, y - radius * 0.25, radius * 0.12, 0, Math.PI * 2);
        ctx.fill();

        // Dark orb above head
        ctx.fillStyle = 'rgba(147, 112, 219, 0.6)';
        ctx.beginPath();
        ctx.arc(x, y - radius * 0.8, radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    renderCrystalGolem(enemy) {
        const ctx = this.ctx;
        const { x, y, radius } = enemy;

        // Crystalline body
        const crystalGradient = ctx.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
        crystalGradient.addColorStop(0, '#7dd3c4');
        crystalGradient.addColorStop(0.5, '#4a9d8b');
        crystalGradient.addColorStop(1, '#2d5a4f');

        ctx.fillStyle = crystalGradient;
        ctx.beginPath();
        ctx.moveTo(x, y - radius * 0.9);
        ctx.lineTo(x + radius * 0.7, y - radius * 0.3);
        ctx.lineTo(x + radius * 0.8, y + radius * 0.5);
        ctx.lineTo(x, y + radius * 0.9);
        ctx.lineTo(x - radius * 0.8, y + radius * 0.5);
        ctx.lineTo(x - radius * 0.7, y - radius * 0.3);
        ctx.closePath();
        ctx.fill();

        // Crystal facets
        ctx.fillStyle = 'rgba(125, 211, 196, 0.5)';
        ctx.beginPath();
        ctx.moveTo(x, y - radius * 0.5);
        ctx.lineTo(x + radius * 0.4, y);
        ctx.lineTo(x, y + radius * 0.4);
        ctx.lineTo(x - radius * 0.4, y);
        ctx.closePath();
        ctx.fill();

        // Glowing red eyes
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.3, y - radius * 0.3);
        ctx.lineTo(x - radius * 0.15, y - radius * 0.2);
        ctx.lineTo(x - radius * 0.3, y - radius * 0.1);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + radius * 0.3, y - radius * 0.3);
        ctx.lineTo(x + radius * 0.15, y - radius * 0.2);
        ctx.lineTo(x + radius * 0.3, y - radius * 0.1);
        ctx.fill();

        // Crystal spikes
        ctx.strokeStyle = '#4a9d8b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - radius * 0.8, y);
        ctx.lineTo(x - radius * 1.1, y - radius * 0.2);
        ctx.moveTo(x + radius * 0.8, y);
        ctx.lineTo(x + radius * 1.1, y - radius * 0.2);
        ctx.stroke();
    }

    showWaveNotification() {
        this.waveNotifications.push({
            wave: this.wave,
            alpha: 1,
            scale: 1.5,
            life: 6 // seconds to display (increased from 3 to 6)
        });
    }
    
    renderWaveNotifications() {
        const ctx = this.ctx;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 3;

        for (let i = this.waveNotifications.length - 1; i >= 0; i--) {
            const notif = this.waveNotifications[i];
            notif.life -= 1 / 60; // Assume 60fps
            notif.alpha = Math.min(1, notif.life);
            notif.scale = 1 + (1.5 - 1) * (1 - notif.life);

            if (notif.life <= 0) {
                this.waveNotifications.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(notif.scale, notif.scale);

            // Background
            ctx.fillStyle = `rgba(0, 0, 0, ${notif.alpha * 0.7})`;
            ctx.fillRect(-150, -40, 300, 80);

            // Border
            ctx.strokeStyle = `rgba(102, 126, 234, ${notif.alpha})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(-150, -40, 300, 80);

            // Text
            ctx.fillStyle = `rgba(255, 255, 255, ${notif.alpha})`;
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`WAVE ${notif.wave}`, 0, 0);

            ctx.restore();
        }
    }
    
    /**
     * Render special event notifications on screen
     */
    renderEventNotifications() {
        const ctx = this.ctx;
        const centerX = this.canvas.width / 2;
        let yOffset = 150; // Start below wave notifications

        for (let i = this.eventNotifications.length - 1; i >= 0; i--) {
            const notif = this.eventNotifications[i];
            notif.life -= 1 / 60; // Assume 60fps
            notif.alpha = Math.min(1, notif.life);
            notif.scale = 1 + (1.3 - 1) * (1 - notif.life);

            if (notif.life <= 0) {
                this.eventNotifications.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.translate(centerX, yOffset);
            ctx.scale(notif.scale, notif.scale);

            // Background with event color tint
            ctx.fillStyle = `rgba(0, 0, 0, ${notif.alpha * 0.8})`;
            ctx.fillRect(-180, -35, 360, 70);

            // Colored border matching event type
            ctx.strokeStyle = notif.color;
            ctx.lineWidth = 4;
            ctx.strokeRect(-180, -35, 360, 70);
            
            // Inner glow (removed expensive shadowBlur for performance)

            // Text with event color
            ctx.fillStyle = notif.color;
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(notif.text, 0, 0);

            ctx.restore();
            
            yOffset += 80; // Stack notifications vertically
        }
    }
    
    /**
     * Render Blood Moon red overlay on screen
     */
    renderBloodMoonOverlay() {
        if (!this.activeEvents.bloodMoon) return;
        
        const ctx = this.ctx;
        
        // Pulsing red overlay
        const pulseIntensity = 0.15 + Math.sin(this.gameTime * 3) * 0.05; // Pulsing effect
        
        ctx.fillStyle = `rgba(139, 0, 0, ${pulseIntensity})`;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Vignette effect (darker edges)
        const gradient = ctx.createRadialGradient(
            this.canvas.width / 2, this.canvas.height / 2, this.canvas.height / 3,
            this.canvas.width / 2, this.canvas.height / 2, this.canvas.height
        );
        gradient.addColorStop(0, 'rgba(139, 0, 0, 0)');
        gradient.addColorStop(1, `rgba(139, 0, 0, ${pulseIntensity * 0.5})`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Get the weapon SVG key for a projectile based on its properties
     * @param {Projectile} proj - The projectile to get the weapon key for
     * @returns {string} - The weapon SVG key
     */
    getProjectileWeaponKey(proj) {
        // Check weaponType first (most reliable)
        if (proj.weaponType) {
            return proj.weaponType;
        }
        // Fallback to legacy property checks
        if (proj.isIceShard) return 'ice_shard';
        if (proj.isSacredCross) return 'sacred_cross';
        if (proj.isPoisonDagger) return 'poison_dagger';
        if (proj.isSpinBlade) return 'spin_blade';
        if (proj.isExplosive) return 'fireball_arc';
        if (proj.homing) return 'magic_wand';
        // Default to magic_wand
        return 'magic_wand';
    }

    /**
     * Draw a projectile directly using canvas API - no SVG images
     * Each weapon type has a distinct visual style using gradients and effects
     * @param {Projectile} proj - The projectile to draw
     * @param {string} weaponKey - The weapon type key
     */
    drawProjectile(proj, weaponKey) {
        const ctx = this.ctx;
        const x = proj.x;
        const y = proj.y;
        const r = proj.radius;

        switch (weaponKey) {
            case 'magic_aura':
                // Purple/pink glow with soft gradient
                ctx.save();
                ctx.shadowBlur = r * 2;
                ctx.shadowColor = '#ff00ff';
                const auraGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
                auraGrad.addColorStop(0, '#ff66ff');
                auraGrad.addColorStop(0.5, '#cc00cc');
                auraGrad.addColorStop(1, 'rgba(150, 0, 150, 0.3)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                // Inner bright core
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, r * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            case 'fireball_arc':
                // Orange/red fireball with glow
                ctx.save();
                ctx.shadowBlur = r * 1.5;
                ctx.shadowColor = '#ff4400';
                const fireGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
                fireGrad.addColorStop(0, '#ffff66');
                fireGrad.addColorStop(0.4, '#ff6600');
                fireGrad.addColorStop(1, '#cc0000');
                ctx.fillStyle = fireGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            case 'magic_wand':
                // Blue/purple magic missile
                ctx.save();
                ctx.shadowBlur = r * 1.2;
                ctx.shadowColor = '#6666ff';
                const wandGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
                wandGrad.addColorStop(0, '#aaccff');
                wandGrad.addColorStop(0.6, '#6666ff');
                wandGrad.addColorStop(1, '#3300cc');
                ctx.fillStyle = wandGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                // White streak effect
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - r * 0.8, y);
                ctx.lineTo(x + r * 0.5, y);
                ctx.stroke();
                ctx.restore();
                break;

            case 'throwing_knife':
                // Silver/gray ellipse (rotated to face direction)
                ctx.save();
                ctx.translate(x, y);
                // Rotate to face velocity direction
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r * 0.5;
                ctx.shadowColor = '#888888';
                const knifeGrad = ctx.createLinearGradient(-r * 1.5, 0, r * 1.5, 0);
                knifeGrad.addColorStop(0, '#666666');
                knifeGrad.addColorStop(0.3, '#cccccc');
                knifeGrad.addColorStop(0.5, '#ffffff');
                knifeGrad.addColorStop(0.7, '#cccccc');
                knifeGrad.addColorStop(1, '#666666');
                ctx.fillStyle = knifeGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, r * 1.8, r * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            case 'lightning_bolt':
                // Yellow lightning with strong glow
                ctx.save();
                ctx.shadowBlur = r * 2.5;
                ctx.shadowColor = '#ffff00';
                const boltGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
                boltGrad.addColorStop(0, '#ffffff');
                boltGrad.addColorStop(0.5, '#ffff00');
                boltGrad.addColorStop(1, '#ffaa00');
                ctx.fillStyle = boltGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                // Extra bright center
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            case 'holy_water':
                // Light blue/cyan with soft glow
                ctx.save();
                ctx.shadowBlur = r * 1.3;
                ctx.shadowColor = '#00ffff';
                const holyGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
                holyGrad.addColorStop(0, '#ffffff');
                holyGrad.addColorStop(0.4, '#66ffff');
                holyGrad.addColorStop(1, '#009999');
                ctx.fillStyle = holyGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                // Sparkle effect
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            case 'ice_shard':
                // Light blue/cyan with sharp edges (diamond shape)
                ctx.save();
                ctx.translate(x, y);
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r;
                ctx.shadowColor = '#00ccff';
                const iceGrad = ctx.createLinearGradient(-r, -r, r, r);
                iceGrad.addColorStop(0, '#e0ffff');
                iceGrad.addColorStop(0.5, '#66ccff');
                iceGrad.addColorStop(1, '#0066cc');
                ctx.fillStyle = iceGrad;
                ctx.beginPath();
                // Diamond shape
                ctx.moveTo(0, -r * 1.4);
                ctx.lineTo(r * 0.7, 0);
                ctx.lineTo(0, r * 1.4);
                ctx.lineTo(-r * 0.7, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                break;

            case 'sacred_cross':
                // Gold/yellow cross shape
                ctx.save();
                ctx.translate(x, y);
                // Sacred Cross rotates around player - face outward from player
                const angle = Math.atan2(y - this.player.y, x - this.player.x);
                ctx.rotate(angle + Math.PI / 2);
                ctx.shadowBlur = r * 1.5;
                ctx.shadowColor = '#ffcc00';
                const crossGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                crossGrad.addColorStop(0, '#ffffaa');
                crossGrad.addColorStop(0.6, '#ffcc00');
                crossGrad.addColorStop(1, '#cc8800');
                ctx.fillStyle = crossGrad;
                // Draw cross shape
                const armW = r * 0.4;
                const armL = r * 1.2;
                ctx.fillRect(-armW / 2, -armL, armW, armL * 2);
                ctx.fillRect(-armL / 2, -armW / 2, armL, armW);
                ctx.restore();
                break;

            case 'poison_dagger':
                // Green poison dart with trail effect
                ctx.save();
                ctx.translate(x, y);
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r;
                ctx.shadowColor = '#00ff00';
                const poisonGrad = ctx.createLinearGradient(-r, 0, r, 0);
                poisonGrad.addColorStop(0, '#006600');
                poisonGrad.addColorStop(0.5, '#00ff00');
                poisonGrad.addColorStop(1, '#66ff66');
                ctx.fillStyle = poisonGrad;
                ctx.beginPath();
                // Dagger shape
                ctx.moveTo(r * 1.5, 0);
                ctx.lineTo(-r * 0.5, r * 0.6);
                ctx.lineTo(-r * 0.8, r * 0.4);
                ctx.lineTo(-r * 0.8, -r * 0.4);
                ctx.lineTo(-r * 0.5, -r * 0.6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                break;

            case 'spin_blade':
                // Silver with blue trail, spinning
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(Date.now() / 100);
                ctx.shadowBlur = r * 1.2;
                ctx.shadowColor = '#0066ff';
                const bladeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                bladeGrad.addColorStop(0, '#ffffff');
                bladeGrad.addColorStop(0.5, '#cccccc');
                bladeGrad.addColorStop(1, '#666666');
                ctx.fillStyle = bladeGrad;
                // Circular blade shape
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                // Blue outer ring
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                break;

            case 'soul_orb':
                // Purple soul orb with ghostly glow
                ctx.save();
                ctx.shadowBlur = r * 2;
                ctx.shadowColor = '#9370db';
                const soulGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
                soulGrad.addColorStop(0, '#e0b0ff');
                soulGrad.addColorStop(0.5, '#9370db');
                soulGrad.addColorStop(1, 'rgba(75, 0, 130, 0.3)');
                ctx.fillStyle = soulGrad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                // Swirl pattern inside
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(224, 176, 255, 0.6)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(x, y, r * 0.6, 0, Math.PI * 1.5);
                ctx.stroke();
                ctx.restore();
                break;

            case 'bone_spear':
                // Bone-colored piercing spear (rotated)
                ctx.save();
                ctx.translate(x, y);
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r * 0.8;
                ctx.shadowColor = '#d4c4a8';
                const boneGrad = ctx.createLinearGradient(-r * 2, 0, r * 2, 0);
                boneGrad.addColorStop(0, '#f5f5dc');
                boneGrad.addColorStop(0.5, '#e8dcc4');
                boneGrad.addColorStop(1, '#d4c4a8');
                ctx.fillStyle = boneGrad;
                // Spear shape
                ctx.beginPath();
                ctx.ellipse(0, 0, r * 2.5, r * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Spear tip
                ctx.fillStyle = '#c4b494';
                ctx.beginPath();
                ctx.moveTo(r * 1.5, 0);
                ctx.lineTo(r * 2.5, -r * 0.4);
                ctx.lineTo(r * 2.5, r * 0.4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                break;

            case 'blood_moon_chakram':
                // Red crescent blade (rotated)
                ctx.save();
                ctx.translate(x, y);
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r * 1.5;
                ctx.shadowColor = '#ff6b6b';
                const chakramGrad = ctx.createLinearGradient(-r, -r, r, r);
                chakramGrad.addColorStop(0, '#ff6b6b');
                chakramGrad.addColorStop(0.5, '#8b0000');
                chakramGrad.addColorStop(1, '#4a0000');
                ctx.fillStyle = chakramGrad;
                // Crescent shape
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0.3, Math.PI - 0.3);
                ctx.arc(r * 0.5, 0, r * 0.8, Math.PI + 0.3, -0.3);
                ctx.closePath();
                ctx.fill();
                // Sharp edge highlight
                ctx.strokeStyle = '#ffcccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.15, 0.4, Math.PI - 0.4);
                ctx.stroke();
                ctx.restore();
                break;

            case 'vampire_dagger':
                // Dark red dagger with blood effect (rotated)
                ctx.save();
                ctx.translate(x, y);
                if (proj.vx !== 0 || proj.vy !== 0) {
                    ctx.rotate(Math.atan2(proj.vy, proj.vx));
                }
                ctx.shadowBlur = r;
                ctx.shadowColor = '#8b0000';
                const daggerGrad = ctx.createLinearGradient(-r * 1.5, 0, r * 1.5, 0);
                daggerGrad.addColorStop(0, '#4a0000');
                daggerGrad.addColorStop(0.5, '#8b0000');
                daggerGrad.addColorStop(1, '#cc0000');
                ctx.fillStyle = daggerGrad;
                // Dagger shape
                ctx.beginPath();
                ctx.moveTo(r * 1.5, 0);
                ctx.lineTo(-r * 0.3, r * 0.5);
                ctx.lineTo(-r * 0.5, r * 0.4);
                ctx.lineTo(-r * 0.8, r * 0.5);
                ctx.lineTo(-r * 0.8, -r * 0.5);
                ctx.lineTo(-r * 0.5, -r * 0.4);
                ctx.lineTo(-r * 0.3, -r * 0.5);
                ctx.closePath();
                ctx.fill();
                // Blood drop
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-r * 0.4, 0, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;

            default:
                // Fallback: simple colored circle with white core
                ctx.fillStyle = proj.color || '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, r * 0.5, 0, Math.PI * 2);
                ctx.fill();
        }
    }

    // OPTIMIZATION: Use separate if statements for frustum culling
    // OPTIMIZATION: Direct canvas drawing - no SVG images, ~5-10x faster than cached canvas approach
    renderProjectiles() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.projectiles.length;
        for (let i = 0; i < len; i++) {
            const proj = this.projectiles[i];
            if (!proj.active) continue;

            // OPTIMIZATION: Separate if statements for better branch prediction
            if (proj.x + proj.radius < camLeft) continue;
            if (proj.x - proj.radius > camRight) continue;
            if (proj.y + proj.radius < camTop) continue;
            if (proj.y - proj.radius > camBottom) continue;

            // Get weapon key and draw directly with canvas API
            const weaponKey = this.getProjectileWeaponKey(proj);
            this.drawProjectile(proj, weaponKey);
        }
    }

    // OPTIMIZATION: Cache array length for iteration
    renderLightningBolts() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.lightningBolts.length;
        for (let i = 0; i < len; i++) {
            const bolt = this.lightningBolts[i];
            // Check if bolt is visible on screen
            const isVisible = bolt.segments.some(seg =>
                seg.x + 10 >= camLeft && seg.x - 10 <= camRight &&
                seg.y + 10 >= camTop && seg.y - 10 <= camBottom
            );

            if (!isVisible) continue;

            const alpha = bolt.life / bolt.maxLife;

            // OPTIMIZATION: Removed expensive shadowBlur - use thicker stroke instead
            // Draw lightning bolt segments
            ctx.strokeStyle = `rgba(251, 191, 36, ${alpha})`; // Yellow-amber color
            ctx.lineWidth = 5; // Increased from 3 to compensate for no glow
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);

            const segLen = bolt.segments.length;
            for (let j = 1; j < segLen; j++) {
                ctx.lineTo(bolt.segments[j].x, bolt.segments[j].y);
            }

            ctx.stroke();

            // Draw inner bright core (no shadow to clear)
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);

            for (let j = 1; j < segLen; j++) {
                ctx.lineTo(bolt.segments[j].x, bolt.segments[j].y);
            }

            ctx.stroke();
        }
    }

    // OPTIMIZATION: Add frustum culling and cache array length
    renderGroundEffects() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.groundEffects.length;
        for (let i = 0; i < len; i++) {
            const effect = this.groundEffects[i];

            // OPTIMIZATION: Frustum culling with separate if statements
            if (effect.x + effect.radius < camLeft) continue;
            if (effect.x - effect.radius > camRight) continue;
            if (effect.y + effect.radius < camTop) continue;
            if (effect.y - effect.radius > camBottom) continue;

            const alpha = (effect.duration / effect.maxDuration) * 0.4;

            // Draw pool
            ctx.fillStyle = `rgba(6, 182, 212, ${alpha})`;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw border
            ctx.strokeStyle = `rgba(6, 182, 212, ${alpha + 0.2})`;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw bubble particles
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * effect.radius * 0.8;
                this.particles.emit(
                    effect.x + Math.cos(angle) * dist,
                    effect.y + Math.sin(angle) * dist,
                    {
                        color: '#67e8f9',
                        size: 2 + Math.random() * 3,
                        life: 0.5,
                        type: 'circle',
                        vy: -20
                    }
                );
            }
        }
    }

    // OPTIMIZATION: Use separate if statements for frustum culling
    renderXpGems() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.xpGems.length;
        for (let i = 0; i < len; i++) {
            const gem = this.xpGems[i];

            // OPTIMIZATION: Separate if statements for better branch prediction
            if (gem.x + gem.radius < camLeft) continue;
            if (gem.x - gem.radius > camRight) continue;
            if (gem.y + gem.radius < camTop) continue;
            if (gem.y - gem.radius > camBottom) continue;

            // Calculate alpha based on lifetime (fade out in last 1.5 seconds)
            let alpha = 1;
            if (gem.lifetime < 1.5) {
                alpha = gem.lifetime / 1.5;
            }

            ctx.globalAlpha = alpha;

            // Draw circular gem (updated from diamond shape)
            ctx.fillStyle = gem.color;
            ctx.beginPath();
            ctx.arc(gem.x, gem.y, gem.radius, 0, Math.PI * 2);
            ctx.fill();

            // Inner highlight for glossy effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(gem.x - gem.radius * 0.25, gem.y - gem.radius * 0.25, gem.radius * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Subtle inner ring for depth
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(gem.x, gem.y, gem.radius * 0.6, 0, Math.PI * 2);
            ctx.stroke();

            // Warning indicator when about to expire (blink in last 1.5 seconds)
            if (gem.lifetime < 1.5) {
                const blink = Math.sin(Date.now() / 50) > 0;
                if (blink) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(gem.x, gem.y, gem.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        ctx.globalAlpha = 1; // Reset alpha
    }

    renderHealthPacks() {
        const ctx = this.ctx;
        const camLeft = this.camera.x - 50;
        const camRight = this.camera.x + this.canvas.width + 50;
        const camTop = this.camera.y - 50;
        const camBottom = this.camera.y + this.canvas.height + 50;

        const len = this.healthPacks.length;
        for (let i = 0; i < len; i++) {
            const pack = this.healthPacks[i];

            // Frustum culling
            if (pack.x + pack.radius < camLeft) continue;
            if (pack.x - pack.radius > camRight) continue;
            if (pack.y + pack.radius < camTop) continue;
            if (pack.y - pack.radius > camBottom) continue;

            const bobY = pack.y + Math.sin(pack.bobOffset) * 3;

            // Draw cross (red cross on white background)
            const size = pack.radius * 2;

            // White background circle
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(pack.x, bobY, pack.radius, 0, Math.PI * 2);
            ctx.fill();

            // Red cross
            ctx.fillStyle = '#ef4444';
            const crossWidth = size * 0.6;
            const crossThickness = size * 0.2;
            ctx.fillRect(pack.x - crossThickness / 2, bobY - size * 0.4, crossThickness, size * 0.8);
            ctx.fillRect(pack.x - size * 0.4, bobY - crossThickness / 2, size * 0.8, crossThickness);

            // Glow effect when magnetized
            if (pack.magnetized) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pack.x, bobY, pack.radius + 4, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    }

    generateDecorations() {
        this.decorations = [];
        const mapWidth = CONFIG.MAP_BOUNDS.width;
        const mapHeight = CONFIG.MAP_BOUNDS.height;

        // Generate trees (dark silhouettes)
        for (let i = 0; i < 80; i++) {
            this.decorations.push({
                type: 'tree',
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight,
                size: 25 + Math.random() * 20,
                variation: Math.floor(Math.random() * 3),
                colorIndex: Math.floor(Math.random() * 4)
            });
        }

        // Generate rocks (gray boulders)
        for (let i = 0; i < 60; i++) {
            this.decorations.push({
                type: 'rock',
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight,
                size: 15 + Math.random() * 15,
                variation: Math.floor(Math.random() * 3),
                colorIndex: Math.floor(Math.random() * 4)
            });
        }

        // Generate grass patches
        for (let i = 0; i < 100; i++) {
            this.decorations.push({
                type: 'grass',
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight,
                size: 10 + Math.random() * 10,
                variation: Math.floor(Math.random() * 4),
                colorIndex: Math.floor(Math.random() * 4)
            });
        }

        // Generate ruins (broken wall segments)
        for (let i = 0; i < 25; i++) {
            this.decorations.push({
                type: 'ruins',
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight,
                size: 30 + Math.random() * 25,
                variation: Math.floor(Math.random() * 4),
                colorIndex: Math.floor(Math.random() * 4)
            });
        }

        // Generate tombstones
        for (let i = 0; i < 40; i++) {
            this.decorations.push({
                type: 'tombstone',
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight,
                size: 12 + Math.random() * 8,
                variation: Math.floor(Math.random() * 3),
                colorIndex: Math.floor(Math.random() * 3)
            });
        }
    }

    // OPTIMIZATION: Cache array length and use separate frustum culling
    renderDecorations() {
        const ctx = this.ctx;
        const camLeft = this.camera.x;
        const camRight = this.camera.x + this.canvas.width;
        const camTop = this.camera.y;
        const camBottom = this.camera.y + this.canvas.height;
        const padding = 100;

        const len = this.decorations.length;
        for (let i = 0; i < len; i++) {
            const dec = this.decorations[i];
            // OPTIMIZATION: Separate if statements for better branch prediction
            if (dec.x < camLeft - padding) continue;
            if (dec.x > camRight + padding) continue;
            if (dec.y < camTop - padding) continue;
            if (dec.y > camBottom + padding) continue;

            switch (dec.type) {
                case 'tree':
                    this.renderTree(dec);
                    break;
                case 'rock':
                    this.renderRock(dec);
                    break;
                case 'grass':
                    this.renderGrass(dec);
                    break;
                case 'ruins':
                    this.renderRuins(dec);
                    break;
                case 'tombstone':
                    this.renderTombstone(dec);
                    break;
            }
        }
    }

    renderTree(dec) {
        const ctx = this.ctx;
        const { x, y, size, variation, colorIndex } = dec;

        // Pick color based on stored colorIndex (no random per-frame)
        const colors = TREE_COLORS[colorIndex % TREE_COLORS.length];

        // Tree trunk
        ctx.fillStyle = colors.trunk;
        ctx.fillRect(x - size * 0.15, y + size * 0.3, size * 0.3, size * 0.7);

        // Tree foliage (dark silhouette)
        ctx.fillStyle = colors.foliage;
        ctx.beginPath();

        if (variation === 0) {
            // Round top tree
            ctx.arc(x, y, size, 0, Math.PI * 2);
        } else if (variation === 1) {
            // Pointy tree
            ctx.moveTo(x - size, y + size * 0.5);
            ctx.lineTo(x, y - size * 0.8);
            ctx.lineTo(x + size, y + size * 0.5);
            ctx.closePath();
        } else {
            // Irregular tree
            ctx.moveTo(x - size * 0.8, y + size * 0.3);
            ctx.lineTo(x - size * 0.5, y - size * 0.6);
            ctx.lineTo(x + size * 0.3, y - size * 0.8);
            ctx.lineTo(x + size * 0.9, y + size * 0.4);
            ctx.lineTo(x + size * 0.4, y + size * 0.6);
            ctx.lineTo(x - size * 0.4, y + size * 0.7);
            ctx.closePath();
        }
        ctx.fill();

        // Darker shadow on foliage
        ctx.fillStyle = colors.shadow;
        ctx.beginPath();
        ctx.arc(x + size * 0.2, y + size * 0.2, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }

    renderRock(dec) {
        const ctx = this.ctx;
        const { x, y, size, variation, colorIndex } = dec;

        // Pick color based on stored colorIndex (no random per-frame)
        const colors = ROCK_COLORS[colorIndex % ROCK_COLORS.length];

        ctx.fillStyle = colors.base;

        if (variation === 0) {
            // Round rock
            ctx.beginPath();
            ctx.ellipse(x, y, size, size * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
        } else if (variation === 1) {
            // Angular rock
            ctx.beginPath();
            ctx.moveTo(x - size * 0.8, y + size * 0.3);
            ctx.lineTo(x - size * 0.4, y - size * 0.6);
            ctx.lineTo(x + size * 0.6, y - size * 0.4);
            ctx.lineTo(x + size * 0.9, y + size * 0.5);
            ctx.lineTo(x + size * 0.2, y + size * 0.7);
            ctx.lineTo(x - size * 0.5, y + size * 0.6);
            ctx.closePath();
            ctx.fill();
        } else {
            // Clustered rocks
            ctx.beginPath();
            ctx.arc(x - size * 0.4, y + size * 0.2, size * 0.5, 0, Math.PI * 2);
            ctx.arc(x + size * 0.3, y + size * 0.3, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x, y - size * 0.3, size * 0.45, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rock highlights
        ctx.fillStyle = colors.highlight;
        ctx.beginPath();
        ctx.arc(x - size * 0.2, y - size * 0.2, size * 0.25, 0, Math.PI * 2);
        ctx.fill();

        // Dark cracks
        ctx.strokeStyle = colors.crack;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - size * 0.3, y);
        ctx.lineTo(x - size * 0.1, y + size * 0.3);
        ctx.moveTo(x + size * 0.2, y - size * 0.2);
        ctx.lineTo(x + size * 0.4, y + size * 0.1);
        ctx.stroke();
    }

    renderGrass(dec) {
        const ctx = this.ctx;
        const { x, y, size, variation, colorIndex } = dec;

        // Pick color based on stored colorIndex (no random per-frame)
        const colors = GRASS_COLORS[colorIndex % GRASS_COLORS.length];

        ctx.fillStyle = colors.blade;

        // Draw grass blades
        const bladeCount = 5 + variation;
        for (let i = 0; i < bladeCount; i++) {
            const angle = (Math.PI / (bladeCount - 1)) * i - Math.PI * 0.3;
            const spread = size * 0.8;
            const startX = x - spread / 2 + (spread / (bladeCount - 1)) * i;

            ctx.beginPath();
            ctx.moveTo(startX, y + size * 0.3);
            ctx.quadraticCurveTo(
                startX + Math.sin(angle) * size * 0.3,
                y - size * 0.2,
                startX + Math.sin(angle) * size * 0.5,
                y - size * 0.5 - Math.random() * size * 0.2
            );
            ctx.quadraticCurveTo(
                startX + Math.sin(angle) * size * 0.2,
                y - size * 0.2,
                startX - size * 0.1,
                y + size * 0.3
            );
            ctx.closePath();
            ctx.fill();
        }

        // Darker center
        ctx.fillStyle = colors.center;
        ctx.beginPath();
        ctx.ellipse(x, y + size * 0.2, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    renderRuins(dec) {
        const ctx = this.ctx;
        const { x, y, size, variation, colorIndex } = dec;

        // Pick color based on stored colorIndex (no random per-frame)
        const colors = RUINS_COLORS[colorIndex % RUINS_COLORS.length];

        ctx.fillStyle = colors.base;
        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 2;

        if (variation === 0) {
            // Broken wall segment
            ctx.fillRect(x - size * 0.8, y, size * 1.6, size * 0.8);
            ctx.strokeRect(x - size * 0.8, y, size * 1.6, size * 0.8);

            // Cracks
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y);
            ctx.lineTo(x - size * 0.3, y + size * 0.5);
            ctx.moveTo(x + size * 0.2, y);
            ctx.lineTo(x + size * 0.4, y + size * 0.6);
            ctx.stroke();

            // Missing chunk
            ctx.fillStyle = colors.missing;
            ctx.beginPath();
            ctx.arc(x + size * 0.5, y + size * 0.4, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
        } else if (variation === 1) {
            // Pillar remnant
            ctx.fillRect(x - size * 0.4, y - size * 0.5, size * 0.8, size * 1.5);
            ctx.strokeRect(x - size * 0.4, y - size * 0.5, size * 0.8, size * 1.5);

            // Broken top
            ctx.beginPath();
            ctx.moveTo(x - size * 0.4, y - size * 0.5);
            ctx.lineTo(x - size * 0.2, y - size * 0.8);
            ctx.lineTo(x + size * 0.3, y - size * 0.5);
            ctx.fill();
        } else if (variation === 2) {
            // Scattered rubble
            const rubblePositions = [
                { dx: -0.5, dy: 0.3, s: 0.4 },
                { dx: 0.3, dy: 0.4, s: 0.35 },
                { dx: 0, dy: -0.2, s: 0.3 },
                { dx: -0.3, dy: -0.4, s: 0.25 },
                { dx: 0.5, dy: 0, s: 0.3 }
            ];

            for (const r of rubblePositions) {
                ctx.beginPath();
                ctx.rect(x + r.dx * size, y + r.dy * size, size * r.s, size * r.s * 0.6);
                ctx.fill();
                ctx.stroke();
            }
        } else {
            // Arch fragment
            ctx.beginPath();
            ctx.arc(x, y + size * 0.5, size * 0.6, Math.PI, 0);
            ctx.lineTo(x + size * 0.7, y + size);
            ctx.lineTo(x - size * 0.7, y + size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }

    renderTombstone(dec) {
        const ctx = this.ctx;
        const { x, y, size, variation, colorIndex } = dec;

        // Pick color based on stored colorIndex (no random per-frame)
        const colors = TOMBSTONE_COLORS[colorIndex % TOMBSTONE_COLORS.length];

        ctx.fillStyle = colors.base;
        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 2;

        if (variation === 0) {
            // Classic rounded tombstone
            ctx.beginPath();
            ctx.moveTo(x - size * 0.4, y + size * 0.5);
            ctx.lineTo(x - size * 0.4, y - size * 0.3);
            ctx.arc(x, y - size * 0.3, size * 0.4, Math.PI, 0);
            ctx.lineTo(x + size * 0.4, y + size * 0.5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Cross engraving
            ctx.strokeStyle = colors.engraving;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - size * 0.2);
            ctx.lineTo(x, y + size * 0.3);
            ctx.moveTo(x - size * 0.15, y);
            ctx.lineTo(x + size * 0.15, y);
            ctx.stroke();
        } else if (variation === 1) {
            // Rectangular tombstone
            ctx.fillRect(x - size * 0.35, y - size * 0.4, size * 0.7, size * 0.9);
            ctx.strokeRect(x - size * 0.35, y - size * 0.4, size * 0.7, size * 0.9);

            // Skull engraving (simple)
            ctx.fillStyle = colors.engraving;
            ctx.beginPath();
            ctx.arc(x, y - size * 0.1, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x - size * 0.1, y);
            ctx.lineTo(x + size * 0.1, y);
            ctx.stroke();
        } else {
            // Broken/tilted tombstone
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(-0.2);

            ctx.beginPath();
            ctx.moveTo(-size * 0.3, size * 0.3);
            ctx.lineTo(-size * 0.3, -size * 0.5);
            ctx.lineTo(size * 0.2, -size * 0.3);
            ctx.lineTo(size * 0.35, size * 0.4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        // Ground shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(x, y + size * 0.5, size * 0.5, size * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==================== INITIALIZATION ====================
const game = new Game();
    </script>
</body>
</html>
